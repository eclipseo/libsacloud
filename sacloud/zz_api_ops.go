// generated by 'github.com/sacloud/libsacloud/internal/tools/gen-api-op'; DO NOT EDIT

package sacloud

import (
	"context"
	"encoding/json"

	"github.com/sacloud/libsacloud/v2/pkg/mapconv"
	"github.com/sacloud/libsacloud/v2/sacloud/types"
)

func init() {

	SetClientFactoryFunc("Archive", func(caller APICaller) interface{} {
		return &ArchiveOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "archive",
		}
	})

	SetClientFactoryFunc("AuthStatus", func(caller APICaller) interface{} {
		return &AuthStatusOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "auth-status",
		}
	})

	SetClientFactoryFunc("AutoBackup", func(caller APICaller) interface{} {
		return &AutoBackupOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Bill", func(caller APICaller) interface{} {
		return &BillOp{
			Client:     caller,
			PathSuffix: "api/system/1.0",
			PathName:   "bill",
		}
	})

	SetClientFactoryFunc("Bridge", func(caller APICaller) interface{} {
		return &BridgeOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "bridge",
		}
	})

	SetClientFactoryFunc("CDROM", func(caller APICaller) interface{} {
		return &CDROMOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "cdrom",
		}
	})

	SetClientFactoryFunc("Coupon", func(caller APICaller) interface{} {
		return &CouponOp{
			Client:     caller,
			PathSuffix: "api/system/1.0",
			PathName:   "coupon",
		}
	})

	SetClientFactoryFunc("Database", func(caller APICaller) interface{} {
		return &DatabaseOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("Disk", func(caller APICaller) interface{} {
		return &DiskOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "disk",
		}
	})

	SetClientFactoryFunc("DiskPlan", func(caller APICaller) interface{} {
		return &DiskPlanOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "product/disk",
		}
	})

	SetClientFactoryFunc("DNS", func(caller APICaller) interface{} {
		return &DNSOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("GSLB", func(caller APICaller) interface{} {
		return &GSLBOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Icon", func(caller APICaller) interface{} {
		return &IconOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "icon",
		}
	})

	SetClientFactoryFunc("Interface", func(caller APICaller) interface{} {
		return &InterfaceOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "interface",
		}
	})

	SetClientFactoryFunc("Internet", func(caller APICaller) interface{} {
		return &InternetOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "internet",
		}
	})

	SetClientFactoryFunc("InternetPlan", func(caller APICaller) interface{} {
		return &InternetPlanOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "product/internet",
		}
	})

	SetClientFactoryFunc("IPAddress", func(caller APICaller) interface{} {
		return &IPAddressOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "ipaddress",
		}
	})

	SetClientFactoryFunc("IPv6Net", func(caller APICaller) interface{} {
		return &IPv6NetOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "ipv6net",
		}
	})

	SetClientFactoryFunc("IPv6Addr", func(caller APICaller) interface{} {
		return &IPv6AddrOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "ipv6addr",
		}
	})

	SetClientFactoryFunc("License", func(caller APICaller) interface{} {
		return &LicenseOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "license",
		}
	})

	SetClientFactoryFunc("LicenseInfo", func(caller APICaller) interface{} {
		return &LicenseInfoOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "product/license",
		}
	})

	SetClientFactoryFunc("LoadBalancer", func(caller APICaller) interface{} {
		return &LoadBalancerOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("MobileGateway", func(caller APICaller) interface{} {
		return &MobileGatewayOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("NFS", func(caller APICaller) interface{} {
		return &NFSOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("Note", func(caller APICaller) interface{} {
		return &NoteOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "note",
		}
	})

	SetClientFactoryFunc("PacketFilter", func(caller APICaller) interface{} {
		return &PacketFilterOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "packetfilter",
		}
	})

	SetClientFactoryFunc("PrivateHost", func(caller APICaller) interface{} {
		return &PrivateHostOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "privatehost",
		}
	})

	SetClientFactoryFunc("PrivateHostPlan", func(caller APICaller) interface{} {
		return &PrivateHostPlanOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "product/privatehost",
		}
	})

	SetClientFactoryFunc("ProxyLB", func(caller APICaller) interface{} {
		return &ProxyLBOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Region", func(caller APICaller) interface{} {
		return &RegionOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "region",
		}
	})

	SetClientFactoryFunc("Server", func(caller APICaller) interface{} {
		return &ServerOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "server",
		}
	})

	SetClientFactoryFunc("ServerPlan", func(caller APICaller) interface{} {
		return &ServerPlanOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "product/server",
		}
	})

	SetClientFactoryFunc("ServiceClass", func(caller APICaller) interface{} {
		return &ServiceClassOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "public/price",
		}
	})

	SetClientFactoryFunc("SIM", func(caller APICaller) interface{} {
		return &SIMOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("SimpleMonitor", func(caller APICaller) interface{} {
		return &SimpleMonitorOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("SSHKey", func(caller APICaller) interface{} {
		return &SSHKeyOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "sshkey",
		}
	})

	SetClientFactoryFunc("Switch", func(caller APICaller) interface{} {
		return &SwitchOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "switch",
		}
	})

	SetClientFactoryFunc("VPCRouter", func(caller APICaller) interface{} {
		return &VPCRouterOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("WebAccel", func(caller APICaller) interface{} {
		return &WebAccelOp{
			Client:     caller,
			PathSuffix: "api/webaccel/1.0",
			PathName:   "web_accel",
		}
	})

	SetClientFactoryFunc("Zone", func(caller APICaller) interface{} {
		return &ZoneOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "zone",
		}
	})
}

/*************************************************
* ArchiveOp
*************************************************/

// ArchiveOp implements ArchiveAPI interface
type ArchiveOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewArchiveOp creates new ArchiveOp instance
func NewArchiveOp(caller APICaller) ArchiveAPI {
	return GetClientFactoryFunc("Archive")(caller).(ArchiveAPI)
}

// Find is API call
func (o *ArchiveOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ArchiveFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &archiveFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ArchiveFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *ArchiveOp) Create(ctx context.Context, zone string, param *ArchiveCreateRequest) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &ArchiveCreateRequest{}
	}
	args := &struct {
		Argparam *ArchiveCreateRequest `mapconv:"Archive,recursive"`
	}{
		Argparam: param,
	}

	v := &archiveCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &archiveCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Archive, nil
}

// CreateBlank is API call
func (o *ArchiveOp) CreateBlank(ctx context.Context, zone string, param *ArchiveCreateBlankRequest) (*Archive, *FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, nil, err
	}

	var body interface{}

	if param == nil {
		param = &ArchiveCreateBlankRequest{}
	}
	args := &struct {
		Argparam *ArchiveCreateBlankRequest `mapconv:"Archive,recursive"`
	}{
		Argparam: param,
	}

	v := &archiveCreateBlankRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, nil, err
	}

	nakedResponse := &archiveCreateBlankResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, nil, err
	}

	results := &archiveCreateBlankResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, nil, err
	}
	return results.Archive, results.FTPServer, nil
}

// Read is API call
func (o *ArchiveOp) Read(ctx context.Context, zone string, id types.ID) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &archiveReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Archive, nil
}

// Update is API call
func (o *ArchiveOp) Update(ctx context.Context, zone string, id types.ID, param *ArchiveUpdateRequest) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ArchiveUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *ArchiveUpdateRequest `mapconv:"Archive,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &archiveUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &archiveUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Archive, nil
}

// Delete is API call
func (o *ArchiveOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *ArchiveOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if openOption == nil {
		openOption = &OpenFTPRequest{}
	}
	args := &struct {
		Argid         types.ID
		ArgopenOption *OpenFTPRequest `mapconv:",squash"`
	}{
		Argid:         id,
		ArgopenOption: openOption,
	}

	v := &archiveOpenFTPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &archiveOpenFTPResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.FTPServer, nil
}

// CloseFTP is API call
func (o *ArchiveOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* AuthStatusOp
*************************************************/

// AuthStatusOp implements AuthStatusAPI interface
type AuthStatusOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewAuthStatusOp creates new AuthStatusOp instance
func NewAuthStatusOp(caller APICaller) AuthStatusAPI {
	return GetClientFactoryFunc("AuthStatus")(caller).(AuthStatusAPI)
}

// Read is API call
func (o *AuthStatusOp) Read(ctx context.Context) (*AuthStatus, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &authStatusReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &authStatusReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.AuthStatus, nil
}

/*************************************************
* AutoBackupOp
*************************************************/

// AutoBackupOp implements AutoBackupAPI interface
type AutoBackupOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewAutoBackupOp creates new AutoBackupOp instance
func NewAutoBackupOp(caller APICaller) AutoBackupAPI {
	return GetClientFactoryFunc("AutoBackup")(caller).(AutoBackupAPI)
}

// Find is API call
func (o *AutoBackupOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*AutoBackupFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &autoBackupFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &autoBackupFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &AutoBackupFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *AutoBackupOp) Create(ctx context.Context, zone string, param *AutoBackupCreateRequest) (*AutoBackup, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &AutoBackupCreateRequest{}
	}
	args := &struct {
		Argparam *AutoBackupCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argparam: param,
	}

	v := &autoBackupCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &autoBackupCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &autoBackupCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.AutoBackup, nil
}

// Read is API call
func (o *AutoBackupOp) Read(ctx context.Context, zone string, id types.ID) (*AutoBackup, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &autoBackupReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &autoBackupReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.AutoBackup, nil
}

// Update is API call
func (o *AutoBackupOp) Update(ctx context.Context, zone string, id types.ID, param *AutoBackupUpdateRequest) (*AutoBackup, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &AutoBackupUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *AutoBackupUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &autoBackupUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &autoBackupUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &autoBackupUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.AutoBackup, nil
}

// Delete is API call
func (o *AutoBackupOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* BillOp
*************************************************/

// BillOp implements BillAPI interface
type BillOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewBillOp creates new BillOp instance
func NewBillOp(caller APICaller) BillAPI {
	return GetClientFactoryFunc("Bill")(caller).(BillAPI)
}

// ByContract is API call
func (o *BillOp) ByContract(ctx context.Context, accountID types.ID) (*BillByContractResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/by-contract/{{.accountID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"accountID":  accountID,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &billByContractResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BillByContractResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// ByContractYear is API call
func (o *BillOp) ByContractYear(ctx context.Context, accountID types.ID, year int) (*BillByContractYearResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/by-contract/{{.accountID}}/{{.year}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"accountID":  accountID,
		"year":       year,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &billByContractYearResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BillByContractYearResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// ByContractYearMonth is API call
func (o *BillOp) ByContractYearMonth(ctx context.Context, accountID types.ID, year int, month int) (*BillByContractYearMonthResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/by-contract/{{.accountID}}/{{.year}}/{{.month}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"accountID":  accountID,
		"year":       year,
		"month":      month,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &billByContractYearMonthResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BillByContractYearMonthResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *BillOp) Read(ctx context.Context, id types.ID) (*BillReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/id/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &billReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BillReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Details is API call
func (o *BillOp) Details(ctx context.Context, MemberCode string, id types.ID) (*BillDetailsResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}detail/{{.MemberCode}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"MemberCode": MemberCode,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &billDetailsResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BillDetailsResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// DetailsCSV is API call
func (o *BillOp) DetailsCSV(ctx context.Context, MemberCode string, id types.ID) (*BillDetailCSV, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}detail/{{.MemberCode}}/{{.id}}/csv", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"MemberCode": MemberCode,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &billDetailsCSVResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &billDetailsCSVResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.BillDetailCSV, nil
}

/*************************************************
* BridgeOp
*************************************************/

// BridgeOp implements BridgeAPI interface
type BridgeOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewBridgeOp creates new BridgeOp instance
func NewBridgeOp(caller APICaller) BridgeAPI {
	return GetClientFactoryFunc("Bridge")(caller).(BridgeAPI)
}

// Find is API call
func (o *BridgeOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*BridgeFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &bridgeFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BridgeFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *BridgeOp) Create(ctx context.Context, zone string, param *BridgeCreateRequest) (*Bridge, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &BridgeCreateRequest{}
	}
	args := &struct {
		Argparam *BridgeCreateRequest `mapconv:"Bridge,recursive"`
	}{
		Argparam: param,
	}

	v := &bridgeCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &bridgeCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Bridge, nil
}

// Read is API call
func (o *BridgeOp) Read(ctx context.Context, zone string, id types.ID) (*Bridge, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &bridgeReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Bridge, nil
}

// Update is API call
func (o *BridgeOp) Update(ctx context.Context, zone string, id types.ID, param *BridgeUpdateRequest) (*Bridge, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &BridgeUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *BridgeUpdateRequest `mapconv:"Bridge,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &bridgeUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &bridgeUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Bridge, nil
}

// Delete is API call
func (o *BridgeOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* CDROMOp
*************************************************/

// CDROMOp implements CDROMAPI interface
type CDROMOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewCDROMOp creates new CDROMOp instance
func NewCDROMOp(caller APICaller) CDROMAPI {
	return GetClientFactoryFunc("CDROM")(caller).(CDROMAPI)
}

// Find is API call
func (o *CDROMOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*CDROMFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &cDROMFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cDROMFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &CDROMFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *CDROMOp) Create(ctx context.Context, zone string, param *CDROMCreateRequest) (*CDROM, *FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, nil, err
	}

	var body interface{}

	if param == nil {
		param = &CDROMCreateRequest{}
	}
	args := &struct {
		Argparam *CDROMCreateRequest `mapconv:"CDROM,recursive"`
	}{
		Argparam: param,
	}

	v := &cDROMCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, nil, err
	}

	nakedResponse := &cDROMCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, nil, err
	}

	results := &cDROMCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, nil, err
	}
	return results.CDROM, results.FTPServer, nil
}

// Read is API call
func (o *CDROMOp) Read(ctx context.Context, zone string, id types.ID) (*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cDROMReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &cDROMReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.CDROM, nil
}

// Update is API call
func (o *CDROMOp) Update(ctx context.Context, zone string, id types.ID, param *CDROMUpdateRequest) (*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &CDROMUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *CDROMUpdateRequest `mapconv:"CDROM,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &cDROMUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cDROMUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &cDROMUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.CDROM, nil
}

// Delete is API call
func (o *CDROMOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *CDROMOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if openOption == nil {
		openOption = &OpenFTPRequest{}
	}
	args := &struct {
		Argid         types.ID
		ArgopenOption *OpenFTPRequest `mapconv:",squash"`
	}{
		Argid:         id,
		ArgopenOption: openOption,
	}

	v := &cDROMOpenFTPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cDROMOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &cDROMOpenFTPResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.FTPServer, nil
}

// CloseFTP is API call
func (o *CDROMOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* CouponOp
*************************************************/

// CouponOp implements CouponAPI interface
type CouponOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewCouponOp creates new CouponOp instance
func NewCouponOp(caller APICaller) CouponAPI {
	return GetClientFactoryFunc("Coupon")(caller).(CouponAPI)
}

// Find is API call
func (o *CouponOp) Find(ctx context.Context, accountID types.ID) (*CouponFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.accountID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"accountID":  accountID,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &couponFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &CouponFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

/*************************************************
* DatabaseOp
*************************************************/

// DatabaseOp implements DatabaseAPI interface
type DatabaseOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDatabaseOp creates new DatabaseOp instance
func NewDatabaseOp(caller APICaller) DatabaseAPI {
	return GetClientFactoryFunc("Database")(caller).(DatabaseAPI)
}

// Find is API call
func (o *DatabaseOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*DatabaseFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &databaseFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DatabaseFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *DatabaseOp) Create(ctx context.Context, zone string, param *DatabaseCreateRequest) (*Database, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &DatabaseCreateRequest{}
	}
	args := &struct {
		Argparam *DatabaseCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argparam: param,
	}

	v := &databaseCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &databaseCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Database, nil
}

// Read is API call
func (o *DatabaseOp) Read(ctx context.Context, zone string, id types.ID) (*Database, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &databaseReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Database, nil
}

// Update is API call
func (o *DatabaseOp) Update(ctx context.Context, zone string, id types.ID, param *DatabaseUpdateRequest) (*Database, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &DatabaseUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *DatabaseUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &databaseUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &databaseUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Database, nil
}

// Delete is API call
func (o *DatabaseOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *DatabaseOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *DatabaseOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *DatabaseOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &databaseShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *DatabaseOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorCPU is API call
func (o *DatabaseOp) MonitorCPU(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*CPUTimeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cpu/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &databaseMonitorCPURequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseMonitorCPUResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &databaseMonitorCPUResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.CPUTimeActivity, nil
}

// MonitorDisk is API call
func (o *DatabaseOp) MonitorDisk(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*DiskActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/disk/0/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &databaseMonitorDiskRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseMonitorDiskResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &databaseMonitorDiskResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DiskActivity, nil
}

// MonitorInterface is API call
func (o *DatabaseOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &databaseMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &databaseMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

// MonitorDatabase is API call
func (o *DatabaseOp) MonitorDatabase(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*DatabaseActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/database/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &databaseMonitorDatabaseRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseMonitorDatabaseResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &databaseMonitorDatabaseResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DatabaseActivity, nil
}

// Status is API call
func (o *DatabaseOp) Status(ctx context.Context, zone string, id types.ID) (*DatabaseStatus, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/status", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &databaseStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &databaseStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DatabaseStatus, nil
}

/*************************************************
* DiskOp
*************************************************/

// DiskOp implements DiskAPI interface
type DiskOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDiskOp creates new DiskOp instance
func NewDiskOp(caller APICaller) DiskAPI {
	return GetClientFactoryFunc("Disk")(caller).(DiskAPI)
}

// Find is API call
func (o *DiskOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*DiskFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &diskFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *DiskOp) Create(ctx context.Context, zone string, param *DiskCreateRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &DiskCreateRequest{}
	}
	args := &struct {
		Argparam *DiskCreateRequest `mapconv:"Disk,recursive"`
	}{
		Argparam: param,
	}

	v := &diskCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// CreateDistantly is API call
func (o *DiskOp) CreateDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"createParam": createParam,
		"distantFrom": distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		ArgcreateParam *DiskCreateRequest `mapconv:"Disk"`
		ArgdistantFrom []types.ID         `mapconv:"DistantFrom"`
	}{
		ArgcreateParam: createParam,
		ArgdistantFrom: distantFrom,
	}

	v := &diskCreateDistantlyRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskCreateDistantlyResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Config is API call
func (o *DiskOp) Config(ctx context.Context, zone string, id types.ID, edit *DiskEditRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"edit":       edit,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if edit == nil {
		edit = &DiskEditRequest{}
	}
	args := &struct {
		Argid   types.ID
		Argedit *DiskEditRequest `mapconv:",squash"`
	}{
		Argid:   id,
		Argedit: edit,
	}

	v := &diskConfigRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// CreateWithConfig is API call
func (o *DiskOp) CreateWithConfig(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if editParam == nil {
		editParam = &DiskEditRequest{}
	}
	if bootAtAvailable == false {
		bootAtAvailable = false
	}
	args := &struct {
		ArgcreateParam     *DiskCreateRequest `mapconv:"Disk"`
		ArgeditParam       *DiskEditRequest   `mapconv:"Config"`
		ArgbootAtAvailable bool               `mapconv:"BootAtAvailable"`
	}{
		ArgcreateParam:     createParam,
		ArgeditParam:       editParam,
		ArgbootAtAvailable: bootAtAvailable,
	}

	v := &diskCreateWithConfigRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateWithConfigResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskCreateWithConfigResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// CreateWithConfigDistantly is API call
func (o *DiskOp) CreateWithConfigDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
		"distantFrom":     distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if editParam == nil {
		editParam = &DiskEditRequest{}
	}
	if bootAtAvailable == false {
		bootAtAvailable = false
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		ArgcreateParam     *DiskCreateRequest `mapconv:"Disk"`
		ArgeditParam       *DiskEditRequest   `mapconv:"Config"`
		ArgbootAtAvailable bool               `mapconv:"BootAtAvailable"`
		ArgdistantFrom     []types.ID         `mapconv:"DistantFrom"`
	}{
		ArgcreateParam:     createParam,
		ArgeditParam:       editParam,
		ArgbootAtAvailable: bootAtAvailable,
		ArgdistantFrom:     distantFrom,
	}

	v := &diskCreateWithConfigDistantlyRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateWithConfigDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskCreateWithConfigDistantlyResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// ToBlank is API call
func (o *DiskOp) ToBlank(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/blank", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ResizePartition is API call
func (o *DiskOp) ResizePartition(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/resize-partition", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToServer is API call
func (o *DiskOp) ConnectToServer(ctx context.Context, zone string, id types.ID, serverID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server/{{.serverID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"serverID":   serverID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromServer is API call
func (o *DiskOp) DisconnectFromServer(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// InstallDistantFrom is API call
func (o *DiskOp) InstallDistantFrom(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"id":           id,
		"installParam": installParam,
		"distantFrom":  distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if installParam == nil {
		installParam = &DiskInstallRequest{}
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		Argid           types.ID
		ArginstallParam *DiskInstallRequest `mapconv:"Disk"`
		ArgdistantFrom  []types.ID          `mapconv:"DistantFrom"`
	}{
		Argid:           id,
		ArginstallParam: installParam,
		ArgdistantFrom:  distantFrom,
	}

	v := &diskInstallDistantFromRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskInstallDistantFromResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskInstallDistantFromResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Install is API call
func (o *DiskOp) Install(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"id":           id,
		"installParam": installParam,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if installParam == nil {
		installParam = &DiskInstallRequest{}
	}
	args := &struct {
		Argid           types.ID
		ArginstallParam *DiskInstallRequest `mapconv:"Disk"`
	}{
		Argid:           id,
		ArginstallParam: installParam,
	}

	v := &diskInstallRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskInstallResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskInstallResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Read is API call
func (o *DiskOp) Read(ctx context.Context, zone string, id types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Update is API call
func (o *DiskOp) Update(ctx context.Context, zone string, id types.ID, param *DiskUpdateRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &DiskUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *DiskUpdateRequest `mapconv:"Disk,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &diskUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Delete is API call
func (o *DiskOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *DiskOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*DiskActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &diskMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DiskActivity, nil
}

/*************************************************
* DiskPlanOp
*************************************************/

// DiskPlanOp implements DiskPlanAPI interface
type DiskPlanOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDiskPlanOp creates new DiskPlanOp instance
func NewDiskPlanOp(caller APICaller) DiskPlanAPI {
	return GetClientFactoryFunc("DiskPlan")(caller).(DiskPlanAPI)
}

// Find is API call
func (o *DiskPlanOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*DiskPlanFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &diskPlanFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskPlanFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskPlanFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *DiskPlanOp) Read(ctx context.Context, zone string, id types.ID) (*DiskPlan, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskPlanReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskPlanReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DiskPlan, nil
}

/*************************************************
* DNSOp
*************************************************/

// DNSOp implements DNSAPI interface
type DNSOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDNSOp creates new DNSOp instance
func NewDNSOp(caller APICaller) DNSAPI {
	return GetClientFactoryFunc("DNS")(caller).(DNSAPI)
}

// Find is API call
func (o *DNSOp) Find(ctx context.Context, conditions *FindCondition) (*DNSFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &dNSFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &dNSFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DNSFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *DNSOp) Create(ctx context.Context, param *DNSCreateRequest) (*DNS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &DNSCreateRequest{}
	}
	args := &struct {
		Argparam *DNSCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argparam: param,
	}

	v := &dNSCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &dNSCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &dNSCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DNS, nil
}

// Read is API call
func (o *DNSOp) Read(ctx context.Context, id types.ID) (*DNS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &dNSReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &dNSReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DNS, nil
}

// Update is API call
func (o *DNSOp) Update(ctx context.Context, id types.ID, param *DNSUpdateRequest) (*DNS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &DNSUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *DNSUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &dNSUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &dNSUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &dNSUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DNS, nil
}

// Delete is API call
func (o *DNSOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* GSLBOp
*************************************************/

// GSLBOp implements GSLBAPI interface
type GSLBOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewGSLBOp creates new GSLBOp instance
func NewGSLBOp(caller APICaller) GSLBAPI {
	return GetClientFactoryFunc("GSLB")(caller).(GSLBAPI)
}

// Find is API call
func (o *GSLBOp) Find(ctx context.Context, conditions *FindCondition) (*GSLBFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &gSLBFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gSLBFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &GSLBFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *GSLBOp) Create(ctx context.Context, param *GSLBCreateRequest) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &GSLBCreateRequest{}
	}
	args := &struct {
		Argparam *GSLBCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argparam: param,
	}

	v := &gSLBCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gSLBCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &gSLBCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.GSLB, nil
}

// Read is API call
func (o *GSLBOp) Read(ctx context.Context, id types.ID) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gSLBReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &gSLBReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.GSLB, nil
}

// Update is API call
func (o *GSLBOp) Update(ctx context.Context, id types.ID, param *GSLBUpdateRequest) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &GSLBUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *GSLBUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &gSLBUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gSLBUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &gSLBUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.GSLB, nil
}

// Delete is API call
func (o *GSLBOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* IconOp
*************************************************/

// IconOp implements IconAPI interface
type IconOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewIconOp creates new IconOp instance
func NewIconOp(caller APICaller) IconAPI {
	return GetClientFactoryFunc("Icon")(caller).(IconAPI)
}

// Find is API call
func (o *IconOp) Find(ctx context.Context, conditions *FindCondition) (*IconFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &iconFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iconFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &IconFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *IconOp) Create(ctx context.Context, param *IconCreateRequest) (*Icon, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &IconCreateRequest{}
	}
	args := &struct {
		Argparam *IconCreateRequest `mapconv:"Icon,recursive"`
	}{
		Argparam: param,
	}

	v := &iconCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iconCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iconCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Icon, nil
}

// Read is API call
func (o *IconOp) Read(ctx context.Context, id types.ID) (*Icon, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iconReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iconReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Icon, nil
}

// Update is API call
func (o *IconOp) Update(ctx context.Context, id types.ID, param *IconUpdateRequest) (*Icon, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &IconUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *IconUpdateRequest `mapconv:"Icon,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &iconUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iconUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iconUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Icon, nil
}

// Delete is API call
func (o *IconOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InterfaceOp
*************************************************/

// InterfaceOp implements InterfaceAPI interface
type InterfaceOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInterfaceOp creates new InterfaceOp instance
func NewInterfaceOp(caller APICaller) InterfaceAPI {
	return GetClientFactoryFunc("Interface")(caller).(InterfaceAPI)
}

// Find is API call
func (o *InterfaceOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*InterfaceFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &interfaceFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InterfaceFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *InterfaceOp) Create(ctx context.Context, zone string, param *InterfaceCreateRequest) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &InterfaceCreateRequest{}
	}
	args := &struct {
		Argparam *InterfaceCreateRequest `mapconv:"Interface,recursive"`
	}{
		Argparam: param,
	}

	v := &interfaceCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &interfaceCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Interface, nil
}

// Read is API call
func (o *InterfaceOp) Read(ctx context.Context, zone string, id types.ID) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &interfaceReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Interface, nil
}

// Update is API call
func (o *InterfaceOp) Update(ctx context.Context, zone string, id types.ID, param *InterfaceUpdateRequest) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InterfaceUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *InterfaceUpdateRequest `mapconv:"Interface,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &interfaceUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &interfaceUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Interface, nil
}

// Delete is API call
func (o *InterfaceOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *InterfaceOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &interfaceMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &interfaceMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

// ConnectToSharedSegment is API call
func (o *InterfaceOp) ConnectToSharedSegment(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/shared", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *InterfaceOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *InterfaceOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToPacketFilter is API call
func (o *InterfaceOp) ConnectToPacketFilter(ctx context.Context, zone string, id types.ID, packetFilterID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter/{{.packetFilterID}}", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"id":             id,
		"packetFilterID": packetFilterID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromPacketFilter is API call
func (o *InterfaceOp) DisconnectFromPacketFilter(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InternetOp
*************************************************/

// InternetOp implements InternetAPI interface
type InternetOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInternetOp creates new InternetOp instance
func NewInternetOp(caller APICaller) InternetAPI {
	return GetClientFactoryFunc("Internet")(caller).(InternetAPI)
}

// Find is API call
func (o *InternetOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*InternetFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &internetFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *InternetOp) Create(ctx context.Context, zone string, param *InternetCreateRequest) (*Internet, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &InternetCreateRequest{}
	}
	args := &struct {
		Argparam *InternetCreateRequest `mapconv:"Internet,recursive"`
	}{
		Argparam: param,
	}

	v := &internetCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Internet, nil
}

// Read is API call
func (o *InternetOp) Read(ctx context.Context, zone string, id types.ID) (*Internet, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Internet, nil
}

// Update is API call
func (o *InternetOp) Update(ctx context.Context, zone string, id types.ID, param *InternetUpdateRequest) (*Internet, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *InternetUpdateRequest `mapconv:"Internet,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &internetUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Internet, nil
}

// Delete is API call
func (o *InternetOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// UpdateBandWidth is API call
func (o *InternetOp) UpdateBandWidth(ctx context.Context, zone string, id types.ID, param *InternetUpdateBandWidthRequest) (*Internet, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/bandwidth", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateBandWidthRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *InternetUpdateBandWidthRequest `mapconv:"Internet,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &internetUpdateBandWidthRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateBandWidthResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetUpdateBandWidthResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Internet, nil
}

// AddSubnet is API call
func (o *InternetOp) AddSubnet(ctx context.Context, zone string, id types.ID, param *InternetAddSubnetRequest) (*InternetSubnetOperationResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetAddSubnetRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *InternetAddSubnetRequest `mapconv:",squash"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &internetAddSubnetRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetAddSubnetResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetAddSubnetResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Subnet, nil
}

// UpdateSubnet is API call
func (o *InternetOp) UpdateSubnet(ctx context.Context, zone string, id types.ID, subnetID types.ID, param *InternetUpdateSubnetRequest) (*InternetSubnetOperationResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet/{{.subnetID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"subnetID":   subnetID,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if subnetID == types.ID(int64(0)) {
		subnetID = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateSubnetRequest{}
	}
	args := &struct {
		Argid       types.ID
		ArgsubnetID types.ID
		Argparam    *InternetUpdateSubnetRequest `mapconv:",squash"`
	}{
		Argid:       id,
		ArgsubnetID: subnetID,
		Argparam:    param,
	}

	v := &internetUpdateSubnetRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateSubnetResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetUpdateSubnetResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Subnet, nil
}

// DeleteSubnet is API call
func (o *InternetOp) DeleteSubnet(ctx context.Context, zone string, id types.ID, subnetID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet/{{.subnetID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"subnetID":   subnetID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *InternetOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*RouterActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &internetMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.RouterActivity, nil
}

// EnableIPv6 is API call
func (o *InternetOp) EnableIPv6(ctx context.Context, zone string, id types.ID) (*IPv6NetInfo, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ipv6net", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetEnableIPv6ResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetEnableIPv6Result{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.IPv6Net, nil
}

// DisableIPv6 is API call
func (o *InternetOp) DisableIPv6(ctx context.Context, zone string, id types.ID, ipv6netID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ipv6net/{{.ipv6netID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"ipv6netID":  ipv6netID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InternetPlanOp
*************************************************/

// InternetPlanOp implements InternetPlanAPI interface
type InternetPlanOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInternetPlanOp creates new InternetPlanOp instance
func NewInternetPlanOp(caller APICaller) InternetPlanAPI {
	return GetClientFactoryFunc("InternetPlan")(caller).(InternetPlanAPI)
}

// Find is API call
func (o *InternetPlanOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*InternetPlanFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &internetPlanFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetPlanFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetPlanFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *InternetPlanOp) Read(ctx context.Context, zone string, id types.ID) (*InternetPlan, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetPlanReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetPlanReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InternetPlan, nil
}

/*************************************************
* IPAddressOp
*************************************************/

// IPAddressOp implements IPAddressAPI interface
type IPAddressOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewIPAddressOp creates new IPAddressOp instance
func NewIPAddressOp(caller APICaller) IPAddressAPI {
	return GetClientFactoryFunc("IPAddress")(caller).(IPAddressAPI)
}

// List is API call
func (o *IPAddressOp) List(ctx context.Context, zone string) (*IPAddressListResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPAddressListResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &IPAddressListResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *IPAddressOp) Read(ctx context.Context, zone string, ipAddress string) (*IPAddress, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.ipAddress}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"ipAddress":  ipAddress,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPAddressReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iPAddressReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.IPAddress, nil
}

// UpdateHostName is API call
func (o *IPAddressOp) UpdateHostName(ctx context.Context, zone string, ipAddress string, hostName string) (*IPAddress, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.ipAddress}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"ipAddress":  ipAddress,
		"hostName":   hostName,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if ipAddress == "" {
		ipAddress = ""
	}
	if hostName == "" {
		hostName = ""
	}
	args := &struct {
		ArgipAddress string
		ArghostName  string `mapconv:"IPAddress.HostName"`
	}{
		ArgipAddress: ipAddress,
		ArghostName:  hostName,
	}

	v := &iPAddressUpdateHostNameRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPAddressUpdateHostNameResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iPAddressUpdateHostNameResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.IPAddress, nil
}

/*************************************************
* IPv6NetOp
*************************************************/

// IPv6NetOp implements IPv6NetAPI interface
type IPv6NetOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewIPv6NetOp creates new IPv6NetOp instance
func NewIPv6NetOp(caller APICaller) IPv6NetAPI {
	return GetClientFactoryFunc("IPv6Net")(caller).(IPv6NetAPI)
}

// List is API call
func (o *IPv6NetOp) List(ctx context.Context, zone string) (*IPv6NetListResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPv6NetListResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &IPv6NetListResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *IPv6NetOp) Read(ctx context.Context, zone string, id types.ID) (*IPv6Net, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPv6NetReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iPv6NetReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.IPv6Net, nil
}

/*************************************************
* IPv6AddrOp
*************************************************/

// IPv6AddrOp implements IPv6AddrAPI interface
type IPv6AddrOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewIPv6AddrOp creates new IPv6AddrOp instance
func NewIPv6AddrOp(caller APICaller) IPv6AddrAPI {
	return GetClientFactoryFunc("IPv6Addr")(caller).(IPv6AddrAPI)
}

// Find is API call
func (o *IPv6AddrOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*IPv6AddrFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &iPv6AddrFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPv6AddrFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &IPv6AddrFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *IPv6AddrOp) Create(ctx context.Context, zone string, param *IPv6AddrCreateRequest) (*IPv6Addr, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &IPv6AddrCreateRequest{}
	}
	args := &struct {
		Argparam *IPv6AddrCreateRequest `mapconv:"IPv6Addr,recursive"`
	}{
		Argparam: param,
	}

	v := &iPv6AddrCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPv6AddrCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iPv6AddrCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.IPv6Addr, nil
}

// Read is API call
func (o *IPv6AddrOp) Read(ctx context.Context, zone string, ipv6addr string) (*IPv6Addr, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         ipv6addr,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPv6AddrReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iPv6AddrReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.IPv6Addr, nil
}

// Update is API call
func (o *IPv6AddrOp) Update(ctx context.Context, zone string, ipv6addr string, param *IPv6AddrUpdateRequest) (*IPv6Addr, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         ipv6addr,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if ipv6addr == "" {
		ipv6addr = ""
	}
	if param == nil {
		param = &IPv6AddrUpdateRequest{}
	}
	args := &struct {
		Argipv6addr string
		Argparam    *IPv6AddrUpdateRequest `mapconv:"IPv6Addr,recursive"`
	}{
		Argipv6addr: ipv6addr,
		Argparam:    param,
	}

	v := &iPv6AddrUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iPv6AddrUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iPv6AddrUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.IPv6Addr, nil
}

// Delete is API call
func (o *IPv6AddrOp) Delete(ctx context.Context, zone string, ipv6addr string) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         ipv6addr,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* LicenseOp
*************************************************/

// LicenseOp implements LicenseAPI interface
type LicenseOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewLicenseOp creates new LicenseOp instance
func NewLicenseOp(caller APICaller) LicenseAPI {
	return GetClientFactoryFunc("License")(caller).(LicenseAPI)
}

// Find is API call
func (o *LicenseOp) Find(ctx context.Context, conditions *FindCondition) (*LicenseFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &licenseFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &licenseFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LicenseFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *LicenseOp) Create(ctx context.Context, param *LicenseCreateRequest) (*License, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &LicenseCreateRequest{}
	}
	args := &struct {
		Argparam *LicenseCreateRequest `mapconv:"License,recursive"`
	}{
		Argparam: param,
	}

	v := &licenseCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &licenseCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &licenseCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.License, nil
}

// Read is API call
func (o *LicenseOp) Read(ctx context.Context, id types.ID) (*License, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &licenseReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &licenseReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.License, nil
}

// Update is API call
func (o *LicenseOp) Update(ctx context.Context, id types.ID, param *LicenseUpdateRequest) (*License, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &LicenseUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *LicenseUpdateRequest `mapconv:"License,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &licenseUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &licenseUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &licenseUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.License, nil
}

// Delete is API call
func (o *LicenseOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* LicenseInfoOp
*************************************************/

// LicenseInfoOp implements LicenseInfoAPI interface
type LicenseInfoOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewLicenseInfoOp creates new LicenseInfoOp instance
func NewLicenseInfoOp(caller APICaller) LicenseInfoAPI {
	return GetClientFactoryFunc("LicenseInfo")(caller).(LicenseInfoAPI)
}

// Find is API call
func (o *LicenseInfoOp) Find(ctx context.Context, conditions *FindCondition) (*LicenseInfoFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &licenseInfoFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &licenseInfoFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LicenseInfoFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *LicenseInfoOp) Read(ctx context.Context, id types.ID) (*LicenseInfo, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &licenseInfoReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &licenseInfoReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LicenseInfo, nil
}

/*************************************************
* LoadBalancerOp
*************************************************/

// LoadBalancerOp implements LoadBalancerAPI interface
type LoadBalancerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewLoadBalancerOp creates new LoadBalancerOp instance
func NewLoadBalancerOp(caller APICaller) LoadBalancerAPI {
	return GetClientFactoryFunc("LoadBalancer")(caller).(LoadBalancerAPI)
}

// Find is API call
func (o *LoadBalancerOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*LoadBalancerFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &loadBalancerFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *LoadBalancerOp) Create(ctx context.Context, zone string, param *LoadBalancerCreateRequest) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &LoadBalancerCreateRequest{}
	}
	args := &struct {
		Argparam *LoadBalancerCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argparam: param,
	}

	v := &loadBalancerCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &loadBalancerCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LoadBalancer, nil
}

// Read is API call
func (o *LoadBalancerOp) Read(ctx context.Context, zone string, id types.ID) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &loadBalancerReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LoadBalancer, nil
}

// Update is API call
func (o *LoadBalancerOp) Update(ctx context.Context, zone string, id types.ID, param *LoadBalancerUpdateRequest) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &LoadBalancerUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *LoadBalancerUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &loadBalancerUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &loadBalancerUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LoadBalancer, nil
}

// Delete is API call
func (o *LoadBalancerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *LoadBalancerOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *LoadBalancerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *LoadBalancerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &loadBalancerShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *LoadBalancerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorInterface is API call
func (o *LoadBalancerOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &loadBalancerMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &loadBalancerMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

// Status is API call
func (o *LoadBalancerOp) Status(ctx context.Context, zone string, id types.ID) (*LoadBalancerStatusResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/status", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

/*************************************************
* MobileGatewayOp
*************************************************/

// MobileGatewayOp implements MobileGatewayAPI interface
type MobileGatewayOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewMobileGatewayOp creates new MobileGatewayOp instance
func NewMobileGatewayOp(caller APICaller) MobileGatewayAPI {
	return GetClientFactoryFunc("MobileGateway")(caller).(MobileGatewayAPI)
}

// Find is API call
func (o *MobileGatewayOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*MobileGatewayFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &mobileGatewayFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &MobileGatewayFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *MobileGatewayOp) Create(ctx context.Context, zone string, param *MobileGatewayCreateRequest) (*MobileGateway, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &MobileGatewayCreateRequest{}
	}
	args := &struct {
		Argparam *MobileGatewayCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argparam: param,
	}

	v := &mobileGatewayCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.MobileGateway, nil
}

// Read is API call
func (o *MobileGatewayOp) Read(ctx context.Context, zone string, id types.ID) (*MobileGateway, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.MobileGateway, nil
}

// Update is API call
func (o *MobileGatewayOp) Update(ctx context.Context, zone string, id types.ID, param *MobileGatewayUpdateRequest) (*MobileGateway, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &MobileGatewayUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *MobileGatewayUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &mobileGatewayUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.MobileGateway, nil
}

// Delete is API call
func (o *MobileGatewayOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *MobileGatewayOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *MobileGatewayOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *MobileGatewayOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &mobileGatewayShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *MobileGatewayOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *MobileGatewayOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/1/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *MobileGatewayOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/1/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// GetDNS is API call
func (o *MobileGatewayOp) GetDNS(ctx context.Context, zone string, id types.ID) (*MobileGatewayDNSSetting, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/dnsresolver", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayGetDNSResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayGetDNSResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIMGroup, nil
}

// SetDNS is API call
func (o *MobileGatewayOp) SetDNS(ctx context.Context, zone string, id types.ID, param *MobileGatewayDNSSetting) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/dnsresolver", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &MobileGatewayDNSSetting{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *MobileGatewayDNSSetting `mapconv:"SIMGroup,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &mobileGatewaySetDNSRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// GetSIMRoutes is API call
func (o *MobileGatewayOp) GetSIMRoutes(ctx context.Context, zone string, id types.ID) ([]*MobileGatewaySIMRoute, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/simroutes", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayGetSIMRoutesResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayGetSIMRoutesResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIMRoutes, nil
}

// SetSIMRoutes is API call
func (o *MobileGatewayOp) SetSIMRoutes(ctx context.Context, zone string, id types.ID, param []*MobileGatewaySIMRouteParam) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/simroutes", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = []*MobileGatewaySIMRouteParam{}
	}
	args := &struct {
		Argid    types.ID
		Argparam []*MobileGatewaySIMRouteParam `mapconv:"[]SIMRoutes,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &mobileGatewaySetSIMRoutesRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ListSIM is API call
func (o *MobileGatewayOp) ListSIM(ctx context.Context, zone string, id types.ID) ([]*MobileGatewaySIMInfo, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/sims", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayListSIMResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayListSIMResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIM, nil
}

// AddSIM is API call
func (o *MobileGatewayOp) AddSIM(ctx context.Context, zone string, id types.ID, param *MobileGatewayAddSIMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/sims", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &MobileGatewayAddSIMRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *MobileGatewayAddSIMRequest `mapconv:"SIM,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &mobileGatewayAddSIMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DeleteSIM is API call
func (o *MobileGatewayOp) DeleteSIM(ctx context.Context, zone string, id types.ID, simID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/sims/{{.simID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"simID":      simID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Logs is API call
func (o *MobileGatewayOp) Logs(ctx context.Context, zone string, id types.ID) ([]*MobileGatewaySIMLogs, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/sessionlog", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayLogsResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayLogsResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Logs, nil
}

// GetTrafficConfig is API call
func (o *MobileGatewayOp) GetTrafficConfig(ctx context.Context, zone string, id types.ID) (*MobileGatewayTrafficControl, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/traffic_monitoring", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayGetTrafficConfigResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayGetTrafficConfigResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.TrafficMonitoring, nil
}

// SetTrafficConfig is API call
func (o *MobileGatewayOp) SetTrafficConfig(ctx context.Context, zone string, id types.ID, param *MobileGatewayTrafficControl) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/traffic_monitoring", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &MobileGatewayTrafficControl{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *MobileGatewayTrafficControl `mapconv:"TrafficMonitoring,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &mobileGatewaySetTrafficConfigRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DeleteTrafficConfig is API call
func (o *MobileGatewayOp) DeleteTrafficConfig(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/traffic_monitoring", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// TrafficStatus is API call
func (o *MobileGatewayOp) TrafficStatus(ctx context.Context, zone string, id types.ID) (*MobileGatewayTrafficStatus, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/mobilegateway/traffic_status", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayTrafficStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayTrafficStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.TrafficStatus, nil
}

// MonitorInterface is API call
func (o *MobileGatewayOp) MonitorInterface(ctx context.Context, zone string, id types.ID, index int, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{if eq .index 0}}{{.index}}{{end}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"index":      index,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if index == 0 {
		index = 0
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argindex     int
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argindex:     index,
		Argcondition: condition,
	}

	v := &mobileGatewayMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &mobileGatewayMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &mobileGatewayMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

/*************************************************
* NFSOp
*************************************************/

// NFSOp implements NFSAPI interface
type NFSOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNFSOp creates new NFSOp instance
func NewNFSOp(caller APICaller) NFSAPI {
	return GetClientFactoryFunc("NFS")(caller).(NFSAPI)
}

// Find is API call
func (o *NFSOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*NFSFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &nFSFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NFSFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *NFSOp) Create(ctx context.Context, zone string, param *NFSCreateRequest) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &NFSCreateRequest{}
	}
	args := &struct {
		Argparam *NFSCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argparam: param,
	}

	v := &nFSCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.NFS, nil
}

// Read is API call
func (o *NFSOp) Read(ctx context.Context, zone string, id types.ID) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.NFS, nil
}

// Update is API call
func (o *NFSOp) Update(ctx context.Context, zone string, id types.ID, param *NFSUpdateRequest) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &NFSUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *NFSUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &nFSUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.NFS, nil
}

// Delete is API call
func (o *NFSOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *NFSOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *NFSOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &nFSShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *NFSOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorFreeDiskSize is API call
func (o *NFSOp) MonitorFreeDiskSize(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*FreeDiskSizeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/database/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &nFSMonitorFreeDiskSizeRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSMonitorFreeDiskSizeResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSMonitorFreeDiskSizeResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.FreeDiskSizeActivity, nil
}

// MonitorInterface is API call
func (o *NFSOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &nFSMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

/*************************************************
* NoteOp
*************************************************/

// NoteOp implements NoteAPI interface
type NoteOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNoteOp creates new NoteOp instance
func NewNoteOp(caller APICaller) NoteAPI {
	return GetClientFactoryFunc("Note")(caller).(NoteAPI)
}

// Find is API call
func (o *NoteOp) Find(ctx context.Context, conditions *FindCondition) (*NoteFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &noteFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NoteFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *NoteOp) Create(ctx context.Context, param *NoteCreateRequest) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &NoteCreateRequest{}
	}
	args := &struct {
		Argparam *NoteCreateRequest `mapconv:"Note,recursive"`
	}{
		Argparam: param,
	}

	v := &noteCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &noteCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Note, nil
}

// Read is API call
func (o *NoteOp) Read(ctx context.Context, id types.ID) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &noteReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Note, nil
}

// Update is API call
func (o *NoteOp) Update(ctx context.Context, id types.ID, param *NoteUpdateRequest) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &NoteUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *NoteUpdateRequest `mapconv:"Note,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &noteUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &noteUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Note, nil
}

// Delete is API call
func (o *NoteOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* PacketFilterOp
*************************************************/

// PacketFilterOp implements PacketFilterAPI interface
type PacketFilterOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewPacketFilterOp creates new PacketFilterOp instance
func NewPacketFilterOp(caller APICaller) PacketFilterAPI {
	return GetClientFactoryFunc("PacketFilter")(caller).(PacketFilterAPI)
}

// Find is API call
func (o *PacketFilterOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*PacketFilterFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &packetFilterFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetFilterFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &PacketFilterFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *PacketFilterOp) Create(ctx context.Context, zone string, param *PacketFilterCreateRequest) (*PacketFilter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &PacketFilterCreateRequest{}
	}
	args := &struct {
		Argparam *PacketFilterCreateRequest `mapconv:"PacketFilter,recursive"`
	}{
		Argparam: param,
	}

	v := &packetFilterCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetFilterCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &packetFilterCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PacketFilter, nil
}

// Read is API call
func (o *PacketFilterOp) Read(ctx context.Context, zone string, id types.ID) (*PacketFilter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetFilterReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &packetFilterReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PacketFilter, nil
}

// Update is API call
func (o *PacketFilterOp) Update(ctx context.Context, zone string, id types.ID, param *PacketFilterUpdateRequest) (*PacketFilter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &PacketFilterUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *PacketFilterUpdateRequest `mapconv:"PacketFilter,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &packetFilterUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetFilterUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &packetFilterUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PacketFilter, nil
}

// Delete is API call
func (o *PacketFilterOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* PrivateHostOp
*************************************************/

// PrivateHostOp implements PrivateHostAPI interface
type PrivateHostOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewPrivateHostOp creates new PrivateHostOp instance
func NewPrivateHostOp(caller APICaller) PrivateHostAPI {
	return GetClientFactoryFunc("PrivateHost")(caller).(PrivateHostAPI)
}

// Find is API call
func (o *PrivateHostOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*PrivateHostFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &privateHostFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &privateHostFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &PrivateHostFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *PrivateHostOp) Create(ctx context.Context, zone string, param *PrivateHostCreateRequest) (*PrivateHost, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &PrivateHostCreateRequest{}
	}
	args := &struct {
		Argparam *PrivateHostCreateRequest `mapconv:"PrivateHost,recursive"`
	}{
		Argparam: param,
	}

	v := &privateHostCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &privateHostCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &privateHostCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PrivateHost, nil
}

// Read is API call
func (o *PrivateHostOp) Read(ctx context.Context, zone string, id types.ID) (*PrivateHost, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &privateHostReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &privateHostReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PrivateHost, nil
}

// Update is API call
func (o *PrivateHostOp) Update(ctx context.Context, zone string, id types.ID, param *PrivateHostUpdateRequest) (*PrivateHost, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &PrivateHostUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *PrivateHostUpdateRequest `mapconv:"PrivateHost,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &privateHostUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &privateHostUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &privateHostUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PrivateHost, nil
}

// Delete is API call
func (o *PrivateHostOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* PrivateHostPlanOp
*************************************************/

// PrivateHostPlanOp implements PrivateHostPlanAPI interface
type PrivateHostPlanOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewPrivateHostPlanOp creates new PrivateHostPlanOp instance
func NewPrivateHostPlanOp(caller APICaller) PrivateHostPlanAPI {
	return GetClientFactoryFunc("PrivateHostPlan")(caller).(PrivateHostPlanAPI)
}

// Find is API call
func (o *PrivateHostPlanOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*PrivateHostPlanFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &privateHostPlanFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &privateHostPlanFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &PrivateHostPlanFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *PrivateHostPlanOp) Read(ctx context.Context, zone string, id types.ID) (*PrivateHostPlan, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &privateHostPlanReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &privateHostPlanReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PrivateHostPlan, nil
}

/*************************************************
* ProxyLBOp
*************************************************/

// ProxyLBOp implements ProxyLBAPI interface
type ProxyLBOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewProxyLBOp creates new ProxyLBOp instance
func NewProxyLBOp(caller APICaller) ProxyLBAPI {
	return GetClientFactoryFunc("ProxyLB")(caller).(ProxyLBAPI)
}

// Find is API call
func (o *ProxyLBOp) Find(ctx context.Context, conditions *FindCondition) (*ProxyLBFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &proxyLBFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ProxyLBFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *ProxyLBOp) Create(ctx context.Context, param *ProxyLBCreateRequest) (*ProxyLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &ProxyLBCreateRequest{}
	}
	args := &struct {
		Argparam *ProxyLBCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argparam: param,
	}

	v := &proxyLBCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLB, nil
}

// Read is API call
func (o *ProxyLBOp) Read(ctx context.Context, id types.ID) (*ProxyLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLB, nil
}

// Update is API call
func (o *ProxyLBOp) Update(ctx context.Context, id types.ID, param *ProxyLBUpdateRequest) (*ProxyLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ProxyLBUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *ProxyLBUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &proxyLBUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLB, nil
}

// Delete is API call
func (o *ProxyLBOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ChangePlan is API call
func (o *ProxyLBOp) ChangePlan(ctx context.Context, id types.ID, param *ProxyLBChangePlanRequest) (*ProxyLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ProxyLBChangePlanRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *ProxyLBChangePlanRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &proxyLBChangePlanRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBChangePlanResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBChangePlanResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLB, nil
}

// GetCertificates is API call
func (o *ProxyLBOp) GetCertificates(ctx context.Context, id types.ID) (*ProxyLBCertificates, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/proxylb/sslcertificate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBGetCertificatesResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBGetCertificatesResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLBCertificates, nil
}

// SetCertificates is API call
func (o *ProxyLBOp) SetCertificates(ctx context.Context, id types.ID, param *ProxyLBSetCertificatesRequest) (*ProxyLBCertificates, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/proxylb/sslcertificate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ProxyLBSetCertificatesRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *ProxyLBSetCertificatesRequest `mapconv:"ProxyLB,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &proxyLBSetCertificatesRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBSetCertificatesResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBSetCertificatesResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLBCertificates, nil
}

// DeleteCertificates is API call
func (o *ProxyLBOp) DeleteCertificates(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/proxylb/sslcertificate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// RenewLetsEncryptCert is API call
func (o *ProxyLBOp) RenewLetsEncryptCert(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/proxylb/letsencryptrenew", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// HealthStatus is API call
func (o *ProxyLBOp) HealthStatus(ctx context.Context, id types.ID) (*ProxyLBHealth, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/health", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBHealthStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBHealthStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLBHealth, nil
}

/*************************************************
* RegionOp
*************************************************/

// RegionOp implements RegionAPI interface
type RegionOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewRegionOp creates new RegionOp instance
func NewRegionOp(caller APICaller) RegionAPI {
	return GetClientFactoryFunc("Region")(caller).(RegionAPI)
}

// Find is API call
func (o *RegionOp) Find(ctx context.Context, conditions *FindCondition) (*RegionFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &regionFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &regionFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &RegionFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *RegionOp) Read(ctx context.Context, id types.ID) (*Region, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &regionReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &regionReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Region, nil
}

/*************************************************
* ServerOp
*************************************************/

// ServerOp implements ServerAPI interface
type ServerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewServerOp creates new ServerOp instance
func NewServerOp(caller APICaller) ServerAPI {
	return GetClientFactoryFunc("Server")(caller).(ServerAPI)
}

// Find is API call
func (o *ServerOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ServerFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &serverFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *ServerOp) Create(ctx context.Context, zone string, param *ServerCreateRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &ServerCreateRequest{}
	}
	args := &struct {
		Argparam *ServerCreateRequest `mapconv:"Server,recursive"`
	}{
		Argparam: param,
	}

	v := &serverCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Server, nil
}

// Read is API call
func (o *ServerOp) Read(ctx context.Context, zone string, id types.ID) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Server, nil
}

// Update is API call
func (o *ServerOp) Update(ctx context.Context, zone string, id types.ID, param *ServerUpdateRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ServerUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *ServerUpdateRequest `mapconv:"Server,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &serverUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Server, nil
}

// Delete is API call
func (o *ServerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ChangePlan is API call
func (o *ServerOp) ChangePlan(ctx context.Context, zone string, id types.ID, plan *ServerChangePlanRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/plan", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"plan":       plan,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if plan == nil {
		plan = &ServerChangePlanRequest{}
	}
	args := &struct {
		Argid   types.ID
		Argplan *ServerChangePlanRequest `mapconv:",squash"`
	}{
		Argid:   id,
		Argplan: plan,
	}

	v := &serverChangePlanRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverChangePlanResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverChangePlanResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Server, nil
}

// InsertCDROM is API call
func (o *ServerOp) InsertCDROM(ctx context.Context, zone string, id types.ID, insertParam *InsertCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if insertParam == nil {
		insertParam = &InsertCDROMRequest{}
	}
	args := &struct {
		Argid          types.ID
		ArginsertParam *InsertCDROMRequest `mapconv:"CDROM"`
	}{
		Argid:          id,
		ArginsertParam: insertParam,
	}

	v := &serverInsertCDROMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// EjectCDROM is API call
func (o *ServerOp) EjectCDROM(ctx context.Context, zone string, id types.ID, insertParam *EjectCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if insertParam == nil {
		insertParam = &EjectCDROMRequest{}
	}
	args := &struct {
		Argid          types.ID
		ArginsertParam *EjectCDROMRequest `mapconv:"CDROM"`
	}{
		Argid:          id,
		ArginsertParam: insertParam,
	}

	v := &serverEjectCDROMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *ServerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *ServerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &serverShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *ServerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *ServerOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*CPUTimeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &serverMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.CPUTimeActivity, nil
}

/*************************************************
* ServerPlanOp
*************************************************/

// ServerPlanOp implements ServerPlanAPI interface
type ServerPlanOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewServerPlanOp creates new ServerPlanOp instance
func NewServerPlanOp(caller APICaller) ServerPlanAPI {
	return GetClientFactoryFunc("ServerPlan")(caller).(ServerPlanAPI)
}

// Find is API call
func (o *ServerPlanOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ServerPlanFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &serverPlanFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverPlanFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerPlanFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *ServerPlanOp) Read(ctx context.Context, zone string, id types.ID) (*ServerPlan, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverPlanReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverPlanReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ServerPlan, nil
}

/*************************************************
* ServiceClassOp
*************************************************/

// ServiceClassOp implements ServiceClassAPI interface
type ServiceClassOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewServiceClassOp creates new ServiceClassOp instance
func NewServiceClassOp(caller APICaller) ServiceClassAPI {
	return GetClientFactoryFunc("ServiceClass")(caller).(ServiceClassAPI)
}

// Find is API call
func (o *ServiceClassOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ServiceClassFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &serviceClassFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serviceClassFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServiceClassFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

/*************************************************
* SIMOp
*************************************************/

// SIMOp implements SIMAPI interface
type SIMOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSIMOp creates new SIMOp instance
func NewSIMOp(caller APICaller) SIMAPI {
	return GetClientFactoryFunc("SIM")(caller).(SIMAPI)
}

// Find is API call
func (o *SIMOp) Find(ctx context.Context, conditions *FindCondition) (*SIMFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &sIMFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *SIMOp) Create(ctx context.Context, param *SIMCreateRequest) (*SIM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &SIMCreateRequest{}
	}
	args := &struct {
		Argparam *SIMCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argparam: param,
	}

	v := &sIMCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIM, nil
}

// Read is API call
func (o *SIMOp) Read(ctx context.Context, id types.ID) (*SIM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIM, nil
}

// Update is API call
func (o *SIMOp) Update(ctx context.Context, id types.ID, param *SIMUpdateRequest) (*SIM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *SIMUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &sIMUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIM, nil
}

// Delete is API call
func (o *SIMOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Activate is API call
func (o *SIMOp) Activate(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/activate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Deactivate is API call
func (o *SIMOp) Deactivate(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/deactivate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// AssignIP is API call
func (o *SIMOp) AssignIP(ctx context.Context, id types.ID, param *SIMAssignIPRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/ip", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMAssignIPRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *SIMAssignIPRequest `mapconv:"SIM,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &sIMAssignIPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ClearIP is API call
func (o *SIMOp) ClearIP(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/ip", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// IMEILock is API call
func (o *SIMOp) IMEILock(ctx context.Context, id types.ID, param *SIMIMEILockRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/imeilock", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMIMEILockRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *SIMIMEILockRequest `mapconv:"SIM,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &sIMIMEILockRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// IMEIUnlock is API call
func (o *SIMOp) IMEIUnlock(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/imeilock", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Logs is API call
func (o *SIMOp) Logs(ctx context.Context, id types.ID) (*SIMLogsResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/sessionlog", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMLogsResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMLogsResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// GetNetworkOperator is API call
func (o *SIMOp) GetNetworkOperator(ctx context.Context, id types.ID) ([]*SIMNetworkOperatorConfig, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/network_operator_config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMGetNetworkOperatorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMGetNetworkOperatorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Configs, nil
}

// SetNetworkOperator is API call
func (o *SIMOp) SetNetworkOperator(ctx context.Context, id types.ID, configs []*SIMNetworkOperatorConfig) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/network_operator_config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"configs":    configs,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if configs == nil {
		configs = []*SIMNetworkOperatorConfig{}
	}
	args := &struct {
		Argid      types.ID
		Argconfigs []*SIMNetworkOperatorConfig `mapconv:"[]NetworkOperatorConfigs,recursive"`
	}{
		Argid:      id,
		Argconfigs: configs,
	}

	v := &sIMSetNetworkOperatorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorSIM is API call
func (o *SIMOp) MonitorSIM(ctx context.Context, id types.ID, condition *MonitorCondition) (*LinkActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/metrics/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &sIMMonitorSIMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMMonitorSIMResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMMonitorSIMResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LinkActivity, nil
}

// Status is API call
func (o *SIMOp) Status(ctx context.Context, id types.ID) (*SIMInfo, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/status", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIM, nil
}

/*************************************************
* SimpleMonitorOp
*************************************************/

// SimpleMonitorOp implements SimpleMonitorAPI interface
type SimpleMonitorOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSimpleMonitorOp creates new SimpleMonitorOp instance
func NewSimpleMonitorOp(caller APICaller) SimpleMonitorAPI {
	return GetClientFactoryFunc("SimpleMonitor")(caller).(SimpleMonitorAPI)
}

// Find is API call
func (o *SimpleMonitorOp) Find(ctx context.Context, conditions *FindCondition) (*SimpleMonitorFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &simpleMonitorFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SimpleMonitorFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *SimpleMonitorOp) Create(ctx context.Context, param *SimpleMonitorCreateRequest) (*SimpleMonitor, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &SimpleMonitorCreateRequest{}
	}
	args := &struct {
		Argparam *SimpleMonitorCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argparam: param,
	}

	v := &simpleMonitorCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SimpleMonitor, nil
}

// Read is API call
func (o *SimpleMonitorOp) Read(ctx context.Context, id types.ID) (*SimpleMonitor, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SimpleMonitor, nil
}

// Update is API call
func (o *SimpleMonitorOp) Update(ctx context.Context, id types.ID, param *SimpleMonitorUpdateRequest) (*SimpleMonitor, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SimpleMonitorUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *SimpleMonitorUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &simpleMonitorUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SimpleMonitor, nil
}

// Delete is API call
func (o *SimpleMonitorOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorResponseTime is API call
func (o *SimpleMonitorOp) MonitorResponseTime(ctx context.Context, id types.ID, condition *MonitorCondition) (*ResponseTimeSecActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}//activity/responsetimesec/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argcondition: condition,
	}

	v := &simpleMonitorMonitorResponseTimeRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorMonitorResponseTimeResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorMonitorResponseTimeResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ResponseTimeSecActivity, nil
}

// HealthStatus is API call
func (o *SimpleMonitorOp) HealthStatus(ctx context.Context, id types.ID) (*SimpleMonitorHealthStatus, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/health", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorHealthStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorHealthStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SimpleMonitorHealthStatus, nil
}

/*************************************************
* SSHKeyOp
*************************************************/

// SSHKeyOp implements SSHKeyAPI interface
type SSHKeyOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSSHKeyOp creates new SSHKeyOp instance
func NewSSHKeyOp(caller APICaller) SSHKeyAPI {
	return GetClientFactoryFunc("SSHKey")(caller).(SSHKeyAPI)
}

// Find is API call
func (o *SSHKeyOp) Find(ctx context.Context, conditions *FindCondition) (*SSHKeyFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &sSHKeyFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SSHKeyFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *SSHKeyOp) Create(ctx context.Context, param *SSHKeyCreateRequest) (*SSHKey, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &SSHKeyCreateRequest{}
	}
	args := &struct {
		Argparam *SSHKeyCreateRequest `mapconv:"SSHKey,recursive"`
	}{
		Argparam: param,
	}

	v := &sSHKeyCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sSHKeyCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SSHKey, nil
}

// Generate is API call
func (o *SSHKeyOp) Generate(ctx context.Context, param *SSHKeyGenerateRequest) (*SSHKeyGenerated, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/generate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &SSHKeyGenerateRequest{}
	}
	args := &struct {
		Argparam *SSHKeyGenerateRequest `mapconv:"SSHKey,recursive"`
	}{
		Argparam: param,
	}

	v := &sSHKeyGenerateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyGenerateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sSHKeyGenerateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SSHKeyGenerated, nil
}

// Read is API call
func (o *SSHKeyOp) Read(ctx context.Context, id types.ID) (*SSHKey, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sSHKeyReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SSHKey, nil
}

// Update is API call
func (o *SSHKeyOp) Update(ctx context.Context, id types.ID, param *SSHKeyUpdateRequest) (*SSHKey, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SSHKeyUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *SSHKeyUpdateRequest `mapconv:"SSHKey,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &sSHKeyUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sSHKeyUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SSHKey, nil
}

// Delete is API call
func (o *SSHKeyOp) Delete(ctx context.Context, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* SwitchOp
*************************************************/

// SwitchOp implements SwitchAPI interface
type SwitchOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSwitchOp creates new SwitchOp instance
func NewSwitchOp(caller APICaller) SwitchAPI {
	return GetClientFactoryFunc("Switch")(caller).(SwitchAPI)
}

// Find is API call
func (o *SwitchOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*SwitchFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &switchFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SwitchFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *SwitchOp) Create(ctx context.Context, zone string, param *SwitchCreateRequest) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &SwitchCreateRequest{}
	}
	args := &struct {
		Argparam *SwitchCreateRequest `mapconv:"Switch,recursive"`
	}{
		Argparam: param,
	}

	v := &switchCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &switchCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Switch, nil
}

// Read is API call
func (o *SwitchOp) Read(ctx context.Context, zone string, id types.ID) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &switchReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Switch, nil
}

// Update is API call
func (o *SwitchOp) Update(ctx context.Context, zone string, id types.ID, param *SwitchUpdateRequest) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SwitchUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *SwitchUpdateRequest `mapconv:"Switch,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &switchUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &switchUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Switch, nil
}

// Delete is API call
func (o *SwitchOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToBridge is API call
func (o *SwitchOp) ConnectToBridge(ctx context.Context, zone string, id types.ID, bridgeID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge/{{.bridgeID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"bridgeID":   bridgeID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromBridge is API call
func (o *SwitchOp) DisconnectFromBridge(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge/", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* VPCRouterOp
*************************************************/

// VPCRouterOp implements VPCRouterAPI interface
type VPCRouterOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewVPCRouterOp creates new VPCRouterOp instance
func NewVPCRouterOp(caller APICaller) VPCRouterAPI {
	return GetClientFactoryFunc("VPCRouter")(caller).(VPCRouterAPI)
}

// Find is API call
func (o *VPCRouterOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*VPCRouterFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &vPCRouterFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &VPCRouterFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *VPCRouterOp) Create(ctx context.Context, zone string, param *VPCRouterCreateRequest) (*VPCRouter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &VPCRouterCreateRequest{}
	}
	args := &struct {
		Argparam *VPCRouterCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argparam: param,
	}

	v := &vPCRouterCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &vPCRouterCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.VPCRouter, nil
}

// Read is API call
func (o *VPCRouterOp) Read(ctx context.Context, zone string, id types.ID) (*VPCRouter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &vPCRouterReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.VPCRouter, nil
}

// Update is API call
func (o *VPCRouterOp) Update(ctx context.Context, zone string, id types.ID, param *VPCRouterUpdateRequest) (*VPCRouter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &VPCRouterUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *VPCRouterUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &vPCRouterUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &vPCRouterUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.VPCRouter, nil
}

// Delete is API call
func (o *VPCRouterOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *VPCRouterOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *VPCRouterOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *VPCRouterOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &vPCRouterShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *VPCRouterOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *VPCRouterOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, nicIndex int, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{.nicIndex}}/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"nicIndex":   nicIndex,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *VPCRouterOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID, nicIndex int) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{.nicIndex}}/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"nicIndex":   nicIndex,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorInterface is API call
func (o *VPCRouterOp) MonitorInterface(ctx context.Context, zone string, id types.ID, index int, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{if eq .index 0}}{{.index}}{{end}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"id":         id,
		"index":      index,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if index == 0 {
		index = 0
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argid        types.ID
		Argindex     int
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argid:        id,
		Argindex:     index,
		Argcondition: condition,
	}

	v := &vPCRouterMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &vPCRouterMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

/*************************************************
* WebAccelOp
*************************************************/

// WebAccelOp implements WebAccelAPI interface
type WebAccelOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewWebAccelOp creates new WebAccelOp instance
func NewWebAccelOp(caller APICaller) WebAccelAPI {
	return GetClientFactoryFunc("WebAccel")(caller).(WebAccelAPI)
}

// List is API call
func (o *WebAccelOp) List(ctx context.Context) (*WebAccelListResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/site", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &webAccelListResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &WebAccelListResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *WebAccelOp) Read(ctx context.Context, id types.ID) (*WebAccel, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/site/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &webAccelReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &webAccelReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.WebAccel, nil
}

// ReadCertificate is API call
func (o *WebAccelOp) ReadCertificate(ctx context.Context, id types.ID) (*WebAccelCerts, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/site/{{.id}}/certificate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &webAccelReadCertificateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &webAccelReadCertificateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Certificate, nil
}

// UpdateCertificate is API call
func (o *WebAccelOp) UpdateCertificate(ctx context.Context, id types.ID, param *WebAccelCertUpdateRequest) (*WebAccelCerts, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/site/{{.id}}/certificate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &WebAccelCertUpdateRequest{}
	}
	args := &struct {
		Argid    types.ID
		Argparam *WebAccelCertUpdateRequest `mapconv:"Certificate,recursive"`
	}{
		Argid:    id,
		Argparam: param,
	}

	v := &webAccelUpdateCertificateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &webAccelUpdateCertificateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &webAccelUpdateCertificateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Certificate, nil
}

// DeleteAllCache is API call
func (o *WebAccelOp) DeleteAllCache(ctx context.Context, param *WebAccelDeleteAllCacheRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/deleteallcache", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if param == nil {
		param = &WebAccelDeleteAllCacheRequest{}
	}
	args := &struct {
		Argparam *WebAccelDeleteAllCacheRequest `mapconv:"Site,recursive"`
	}{
		Argparam: param,
	}

	v := &webAccelDeleteAllCacheRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DeleteCache is API call
func (o *WebAccelOp) DeleteCache(ctx context.Context, param *WebAccelDeleteCacheRequest) ([]*WebAccelDeleteCacheResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/deletecache", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if param == nil {
		param = &WebAccelDeleteCacheRequest{}
	}
	args := &struct {
		Argparam *WebAccelDeleteCacheRequest `mapconv:",squash"`
	}{
		Argparam: param,
	}

	v := &webAccelDeleteCacheRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &webAccelDeleteCacheResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &webAccelDeleteCacheResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Results, nil
}

/*************************************************
* ZoneOp
*************************************************/

// ZoneOp implements ZoneAPI interface
type ZoneOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewZoneOp creates new ZoneOp instance
func NewZoneOp(caller APICaller) ZoneAPI {
	return GetClientFactoryFunc("Zone")(caller).(ZoneAPI)
}

// Find is API call
func (o *ZoneOp) Find(ctx context.Context, conditions *FindCondition) (*ZoneFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argconditions: conditions,
	}

	v := &zoneFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &zoneFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ZoneFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *ZoneOp) Read(ctx context.Context, id types.ID) (*Zone, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       APIDefaultZone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &zoneReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &zoneReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Zone, nil
}
