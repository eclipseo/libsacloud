// generated by 'github.com/sacloud/libsacloud/internal/tools/gen-api-op'; DO NOT EDIT

package sacloud

import (
	"context"
	"encoding/json"

	"github.com/sacloud/libsacloud/v2/pkg/mapconv"
	"github.com/sacloud/libsacloud/v2/sacloud/types"
)

func init() {

	SetClientFactoryFunc("Archive", func(caller APICaller) interface{} {
		return &ArchiveOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "archive",
		}
	})

	SetClientFactoryFunc("AuthStatus", func(caller APICaller) interface{} {
		return &AuthStatusOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "auth-status",
		}
	})

	SetClientFactoryFunc("AutoBackup", func(caller APICaller) interface{} {
		return &AutoBackupOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Bridge", func(caller APICaller) interface{} {
		return &BridgeOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "bridge",
		}
	})

	SetClientFactoryFunc("CDROM", func(caller APICaller) interface{} {
		return &CDROMOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "cdrom",
		}
	})

	SetClientFactoryFunc("Disk", func(caller APICaller) interface{} {
		return &DiskOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "disk",
		}
	})

	SetClientFactoryFunc("DNS", func(caller APICaller) interface{} {
		return &DNSOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("GSLB", func(caller APICaller) interface{} {
		return &GSLBOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Icon", func(caller APICaller) interface{} {
		return &IconOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "icon",
		}
	})

	SetClientFactoryFunc("Interface", func(caller APICaller) interface{} {
		return &InterfaceOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "interface",
		}
	})

	SetClientFactoryFunc("Internet", func(caller APICaller) interface{} {
		return &InternetOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "internet",
		}
	})

	SetClientFactoryFunc("LoadBalancer", func(caller APICaller) interface{} {
		return &LoadBalancerOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("NFS", func(caller APICaller) interface{} {
		return &NFSOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("Note", func(caller APICaller) interface{} {
		return &NoteOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "note",
		}
	})

	SetClientFactoryFunc("PacketFilter", func(caller APICaller) interface{} {
		return &PacketFilterOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "packetfilter",
		}
	})

	SetClientFactoryFunc("ProxyLB", func(caller APICaller) interface{} {
		return &ProxyLBOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Region", func(caller APICaller) interface{} {
		return &RegionOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "region",
		}
	})

	SetClientFactoryFunc("Server", func(caller APICaller) interface{} {
		return &ServerOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "server",
		}
	})

	SetClientFactoryFunc("SIM", func(caller APICaller) interface{} {
		return &SIMOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("SimpleMonitor", func(caller APICaller) interface{} {
		return &SimpleMonitorOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("SSHKey", func(caller APICaller) interface{} {
		return &SSHKeyOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "sshkey",
		}
	})

	SetClientFactoryFunc("Switch", func(caller APICaller) interface{} {
		return &SwitchOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "switch",
		}
	})

	SetClientFactoryFunc("VPCRouter", func(caller APICaller) interface{} {
		return &VPCRouterOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("Zone", func(caller APICaller) interface{} {
		return &ZoneOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "zone",
		}
	})
}

/*************************************************
* ArchiveOp
*************************************************/

// ArchiveOp implements ArchiveAPI interface
type ArchiveOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewArchiveOp creates new ArchiveOp instance
func NewArchiveOp(caller APICaller) ArchiveAPI {
	return GetClientFactoryFunc("Archive")(caller).(ArchiveAPI)
}

// Find is API call
func (o *ArchiveOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ArchiveFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &archiveFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ArchiveFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *ArchiveOp) Create(ctx context.Context, zone string, param *ArchiveCreateRequest) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &ArchiveCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *ArchiveCreateRequest `mapconv:"Archive,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &archiveCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &archiveCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Archive, nil
}

// CreateBlank is API call
func (o *ArchiveOp) CreateBlank(ctx context.Context, zone string, param *ArchiveCreateBlankRequest) (*Archive, *FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &ArchiveCreateBlankRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *ArchiveCreateBlankRequest `mapconv:"Archive,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &archiveCreateBlankRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, nil, err
	}

	nakedResponse := &archiveCreateBlankResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, nil, err
	}

	results := &archiveCreateBlankResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, nil, err
	}
	return results.Archive, results.FTPServer, nil
}

// Read is API call
func (o *ArchiveOp) Read(ctx context.Context, zone string, id types.ID) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &archiveReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Archive, nil
}

// Update is API call
func (o *ArchiveOp) Update(ctx context.Context, zone string, id types.ID, param *ArchiveUpdateRequest) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ArchiveUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *ArchiveUpdateRequest `mapconv:"Archive,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &archiveUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &archiveUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Archive, nil
}

// Delete is API call
func (o *ArchiveOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *ArchiveOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if openOption == nil {
		openOption = &OpenFTPRequest{}
	}
	args := &struct {
		Argzone       string
		Argid         types.ID
		ArgopenOption *OpenFTPRequest `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argid:         id,
		ArgopenOption: openOption,
	}

	v := &archiveOpenFTPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &archiveOpenFTPResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.FTPServer, nil
}

// CloseFTP is API call
func (o *ArchiveOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* AuthStatusOp
*************************************************/

// AuthStatusOp implements AuthStatusAPI interface
type AuthStatusOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewAuthStatusOp creates new AuthStatusOp instance
func NewAuthStatusOp(caller APICaller) AuthStatusAPI {
	return GetClientFactoryFunc("AuthStatus")(caller).(AuthStatusAPI)
}

// Read is API call
func (o *AuthStatusOp) Read(ctx context.Context, zone string) (*AuthStatus, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &authStatusReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &authStatusReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.AuthStatus, nil
}

/*************************************************
* AutoBackupOp
*************************************************/

// AutoBackupOp implements AutoBackupAPI interface
type AutoBackupOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewAutoBackupOp creates new AutoBackupOp instance
func NewAutoBackupOp(caller APICaller) AutoBackupAPI {
	return GetClientFactoryFunc("AutoBackup")(caller).(AutoBackupAPI)
}

// Find is API call
func (o *AutoBackupOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*AutoBackupFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &autoBackupFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &autoBackupFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &AutoBackupFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *AutoBackupOp) Create(ctx context.Context, zone string, param *AutoBackupCreateRequest) (*AutoBackup, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &AutoBackupCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *AutoBackupCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &autoBackupCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &autoBackupCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &autoBackupCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.AutoBackup, nil
}

// Read is API call
func (o *AutoBackupOp) Read(ctx context.Context, zone string, id types.ID) (*AutoBackup, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &autoBackupReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &autoBackupReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.AutoBackup, nil
}

// Update is API call
func (o *AutoBackupOp) Update(ctx context.Context, zone string, id types.ID, param *AutoBackupUpdateRequest) (*AutoBackup, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &AutoBackupUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *AutoBackupUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &autoBackupUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &autoBackupUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &autoBackupUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.AutoBackup, nil
}

// Delete is API call
func (o *AutoBackupOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* BridgeOp
*************************************************/

// BridgeOp implements BridgeAPI interface
type BridgeOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewBridgeOp creates new BridgeOp instance
func NewBridgeOp(caller APICaller) BridgeAPI {
	return GetClientFactoryFunc("Bridge")(caller).(BridgeAPI)
}

// Find is API call
func (o *BridgeOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*BridgeFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &bridgeFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BridgeFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *BridgeOp) Create(ctx context.Context, zone string, param *BridgeCreateRequest) (*Bridge, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &BridgeCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *BridgeCreateRequest `mapconv:"Bridge,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &bridgeCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &bridgeCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Bridge, nil
}

// Read is API call
func (o *BridgeOp) Read(ctx context.Context, zone string, id types.ID) (*Bridge, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &bridgeReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Bridge, nil
}

// Update is API call
func (o *BridgeOp) Update(ctx context.Context, zone string, id types.ID, param *BridgeUpdateRequest) (*Bridge, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &BridgeUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *BridgeUpdateRequest `mapconv:"Bridge,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &bridgeUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &bridgeUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Bridge, nil
}

// Delete is API call
func (o *BridgeOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* CDROMOp
*************************************************/

// CDROMOp implements CDROMAPI interface
type CDROMOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewCDROMOp creates new CDROMOp instance
func NewCDROMOp(caller APICaller) CDROMAPI {
	return GetClientFactoryFunc("CDROM")(caller).(CDROMAPI)
}

// Find is API call
func (o *CDROMOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*CDROMFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &cDROMFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cDROMFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &CDROMFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *CDROMOp) Create(ctx context.Context, zone string, param *CDROMCreateRequest) (*CDROM, *FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &CDROMCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *CDROMCreateRequest `mapconv:"CDROM,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &cDROMCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, nil, err
	}

	nakedResponse := &cDROMCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, nil, err
	}

	results := &cDROMCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, nil, err
	}
	return results.CDROM, results.FTPServer, nil
}

// Read is API call
func (o *CDROMOp) Read(ctx context.Context, zone string, id types.ID) (*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cDROMReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &cDROMReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.CDROM, nil
}

// Update is API call
func (o *CDROMOp) Update(ctx context.Context, zone string, id types.ID, param *CDROMUpdateRequest) (*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &CDROMUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *CDROMUpdateRequest `mapconv:"CDROM,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &cDROMUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cDROMUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &cDROMUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.CDROM, nil
}

// Delete is API call
func (o *CDROMOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *CDROMOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if openOption == nil {
		openOption = &OpenFTPRequest{}
	}
	args := &struct {
		Argzone       string
		Argid         types.ID
		ArgopenOption *OpenFTPRequest `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argid:         id,
		ArgopenOption: openOption,
	}

	v := &cDROMOpenFTPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cDROMOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &cDROMOpenFTPResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.FTPServer, nil
}

// CloseFTP is API call
func (o *CDROMOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* DiskOp
*************************************************/

// DiskOp implements DiskAPI interface
type DiskOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDiskOp creates new DiskOp instance
func NewDiskOp(caller APICaller) DiskAPI {
	return GetClientFactoryFunc("Disk")(caller).(DiskAPI)
}

// Find is API call
func (o *DiskOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*DiskFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &diskFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *DiskOp) Create(ctx context.Context, zone string, param *DiskCreateRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &DiskCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *DiskCreateRequest `mapconv:"Disk,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &diskCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// CreateDistantly is API call
func (o *DiskOp) CreateDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"createParam": createParam,
		"distantFrom": distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		Argzone        string
		ArgcreateParam *DiskCreateRequest `mapconv:"Disk"`
		ArgdistantFrom []types.ID         `mapconv:"DistantFrom"`
	}{
		Argzone:        zone,
		ArgcreateParam: createParam,
		ArgdistantFrom: distantFrom,
	}

	v := &diskCreateDistantlyRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskCreateDistantlyResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Config is API call
func (o *DiskOp) Config(ctx context.Context, zone string, id types.ID, edit *DiskEditRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"edit":       edit,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if edit == nil {
		edit = &DiskEditRequest{}
	}
	args := &struct {
		Argzone string
		Argid   types.ID
		Argedit *DiskEditRequest `mapconv:",squash"`
	}{
		Argzone: zone,
		Argid:   id,
		Argedit: edit,
	}

	v := &diskConfigRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// CreateWithConfig is API call
func (o *DiskOp) CreateWithConfig(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"zone":            zone,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if editParam == nil {
		editParam = &DiskEditRequest{}
	}
	if bootAtAvailable == false {
		bootAtAvailable = false
	}
	args := &struct {
		Argzone            string
		ArgcreateParam     *DiskCreateRequest `mapconv:"Disk"`
		ArgeditParam       *DiskEditRequest   `mapconv:"Config"`
		ArgbootAtAvailable bool               `mapconv:"BootAtAvailable"`
	}{
		Argzone:            zone,
		ArgcreateParam:     createParam,
		ArgeditParam:       editParam,
		ArgbootAtAvailable: bootAtAvailable,
	}

	v := &diskCreateWithConfigRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateWithConfigResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskCreateWithConfigResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// CreateWithConfigDistantly is API call
func (o *DiskOp) CreateWithConfigDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"zone":            zone,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
		"distantFrom":     distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if editParam == nil {
		editParam = &DiskEditRequest{}
	}
	if bootAtAvailable == false {
		bootAtAvailable = false
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		Argzone            string
		ArgcreateParam     *DiskCreateRequest `mapconv:"Disk"`
		ArgeditParam       *DiskEditRequest   `mapconv:"Config"`
		ArgbootAtAvailable bool               `mapconv:"BootAtAvailable"`
		ArgdistantFrom     []types.ID         `mapconv:"DistantFrom"`
	}{
		Argzone:            zone,
		ArgcreateParam:     createParam,
		ArgeditParam:       editParam,
		ArgbootAtAvailable: bootAtAvailable,
		ArgdistantFrom:     distantFrom,
	}

	v := &diskCreateWithConfigDistantlyRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateWithConfigDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskCreateWithConfigDistantlyResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// ToBlank is API call
func (o *DiskOp) ToBlank(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/blank", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ResizePartition is API call
func (o *DiskOp) ResizePartition(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/resize-partition", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToServer is API call
func (o *DiskOp) ConnectToServer(ctx context.Context, zone string, id types.ID, serverID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server/{{.serverID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"serverID":   serverID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromServer is API call
func (o *DiskOp) DisconnectFromServer(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// InstallDistantFrom is API call
func (o *DiskOp) InstallDistantFrom(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"zone":         zone,
		"id":           id,
		"installParam": installParam,
		"distantFrom":  distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if installParam == nil {
		installParam = &DiskInstallRequest{}
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		Argzone         string
		Argid           types.ID
		ArginstallParam *DiskInstallRequest `mapconv:"Disk"`
		ArgdistantFrom  []types.ID          `mapconv:"DistantFrom"`
	}{
		Argzone:         zone,
		Argid:           id,
		ArginstallParam: installParam,
		ArgdistantFrom:  distantFrom,
	}

	v := &diskInstallDistantFromRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskInstallDistantFromResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskInstallDistantFromResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Install is API call
func (o *DiskOp) Install(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"zone":         zone,
		"id":           id,
		"installParam": installParam,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if installParam == nil {
		installParam = &DiskInstallRequest{}
	}
	args := &struct {
		Argzone         string
		Argid           types.ID
		ArginstallParam *DiskInstallRequest `mapconv:"Disk"`
	}{
		Argzone:         zone,
		Argid:           id,
		ArginstallParam: installParam,
	}

	v := &diskInstallRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskInstallResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskInstallResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Read is API call
func (o *DiskOp) Read(ctx context.Context, zone string, id types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Update is API call
func (o *DiskOp) Update(ctx context.Context, zone string, id types.ID, param *DiskUpdateRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &DiskUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *DiskUpdateRequest `mapconv:"Disk,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &diskUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Disk, nil
}

// Delete is API call
func (o *DiskOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *DiskOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*DiskActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &diskMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &diskMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DiskActivity, nil
}

/*************************************************
* DNSOp
*************************************************/

// DNSOp implements DNSAPI interface
type DNSOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDNSOp creates new DNSOp instance
func NewDNSOp(caller APICaller) DNSAPI {
	return GetClientFactoryFunc("DNS")(caller).(DNSAPI)
}

// Find is API call
func (o *DNSOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*DNSFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &dNSFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &dNSFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DNSFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *DNSOp) Create(ctx context.Context, zone string, param *DNSCreateRequest) (*DNS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &DNSCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *DNSCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &dNSCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &dNSCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &dNSCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DNS, nil
}

// Read is API call
func (o *DNSOp) Read(ctx context.Context, zone string, id types.ID) (*DNS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &dNSReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &dNSReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DNS, nil
}

// Update is API call
func (o *DNSOp) Update(ctx context.Context, zone string, id types.ID, param *DNSUpdateRequest) (*DNS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &DNSUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *DNSUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &dNSUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &dNSUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &dNSUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.DNS, nil
}

// Delete is API call
func (o *DNSOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* GSLBOp
*************************************************/

// GSLBOp implements GSLBAPI interface
type GSLBOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewGSLBOp creates new GSLBOp instance
func NewGSLBOp(caller APICaller) GSLBAPI {
	return GetClientFactoryFunc("GSLB")(caller).(GSLBAPI)
}

// Find is API call
func (o *GSLBOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*GSLBFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &gSLBFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gSLBFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &GSLBFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *GSLBOp) Create(ctx context.Context, zone string, param *GSLBCreateRequest) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &GSLBCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *GSLBCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &gSLBCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gSLBCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &gSLBCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.GSLB, nil
}

// Read is API call
func (o *GSLBOp) Read(ctx context.Context, zone string, id types.ID) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gSLBReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &gSLBReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.GSLB, nil
}

// Update is API call
func (o *GSLBOp) Update(ctx context.Context, zone string, id types.ID, param *GSLBUpdateRequest) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &GSLBUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *GSLBUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &gSLBUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gSLBUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &gSLBUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.GSLB, nil
}

// Delete is API call
func (o *GSLBOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* IconOp
*************************************************/

// IconOp implements IconAPI interface
type IconOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewIconOp creates new IconOp instance
func NewIconOp(caller APICaller) IconAPI {
	return GetClientFactoryFunc("Icon")(caller).(IconAPI)
}

// Find is API call
func (o *IconOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*IconFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &iconFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iconFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &IconFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *IconOp) Create(ctx context.Context, zone string, param *IconCreateRequest) (*Icon, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &IconCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *IconCreateRequest `mapconv:"Icon,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &iconCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iconCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iconCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Icon, nil
}

// Read is API call
func (o *IconOp) Read(ctx context.Context, zone string, id types.ID) (*Icon, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iconReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iconReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Icon, nil
}

// Update is API call
func (o *IconOp) Update(ctx context.Context, zone string, id types.ID, param *IconUpdateRequest) (*Icon, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &IconUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *IconUpdateRequest `mapconv:"Icon,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &iconUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &iconUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &iconUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Icon, nil
}

// Delete is API call
func (o *IconOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InterfaceOp
*************************************************/

// InterfaceOp implements InterfaceAPI interface
type InterfaceOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInterfaceOp creates new InterfaceOp instance
func NewInterfaceOp(caller APICaller) InterfaceAPI {
	return GetClientFactoryFunc("Interface")(caller).(InterfaceAPI)
}

// Find is API call
func (o *InterfaceOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*InterfaceFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &interfaceFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InterfaceFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *InterfaceOp) Create(ctx context.Context, zone string, param *InterfaceCreateRequest) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &InterfaceCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *InterfaceCreateRequest `mapconv:"Interface,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &interfaceCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &interfaceCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Interface, nil
}

// Read is API call
func (o *InterfaceOp) Read(ctx context.Context, zone string, id types.ID) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &interfaceReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Interface, nil
}

// Update is API call
func (o *InterfaceOp) Update(ctx context.Context, zone string, id types.ID, param *InterfaceUpdateRequest) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InterfaceUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *InterfaceUpdateRequest `mapconv:"Interface,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &interfaceUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &interfaceUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Interface, nil
}

// Delete is API call
func (o *InterfaceOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *InterfaceOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &interfaceMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &interfaceMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

// ConnectToSharedSegment is API call
func (o *InterfaceOp) ConnectToSharedSegment(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/shared", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *InterfaceOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *InterfaceOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToPacketFilter is API call
func (o *InterfaceOp) ConnectToPacketFilter(ctx context.Context, zone string, id types.ID, packetFilterID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter/{{.packetFilterID}}", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"packetFilterID": packetFilterID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromPacketFilter is API call
func (o *InterfaceOp) DisconnectFromPacketFilter(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InternetOp
*************************************************/

// InternetOp implements InternetAPI interface
type InternetOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInternetOp creates new InternetOp instance
func NewInternetOp(caller APICaller) InternetAPI {
	return GetClientFactoryFunc("Internet")(caller).(InternetAPI)
}

// Find is API call
func (o *InternetOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*InternetFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &internetFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *InternetOp) Create(ctx context.Context, zone string, param *InternetCreateRequest) (*Internet, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &InternetCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *InternetCreateRequest `mapconv:"Internet,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &internetCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Internet, nil
}

// Read is API call
func (o *InternetOp) Read(ctx context.Context, zone string, id types.ID) (*Internet, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Internet, nil
}

// Update is API call
func (o *InternetOp) Update(ctx context.Context, zone string, id types.ID, param *InternetUpdateRequest) (*Internet, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *InternetUpdateRequest `mapconv:"Internet,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &internetUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Internet, nil
}

// Delete is API call
func (o *InternetOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// UpdateBandWidth is API call
func (o *InternetOp) UpdateBandWidth(ctx context.Context, zone string, id types.ID, param *InternetUpdateBandWidthRequest) (*Internet, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/bandwidth", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateBandWidthRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *InternetUpdateBandWidthRequest `mapconv:"Internet,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &internetUpdateBandWidthRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateBandWidthResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetUpdateBandWidthResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Internet, nil
}

// AddSubnet is API call
func (o *InternetOp) AddSubnet(ctx context.Context, zone string, id types.ID, param *InternetAddSubnetRequest) (*InternetSubnetOperationResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetAddSubnetRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *InternetAddSubnetRequest `mapconv:",squash"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &internetAddSubnetRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetAddSubnetResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetAddSubnetResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Subnet, nil
}

// UpdateSubnet is API call
func (o *InternetOp) UpdateSubnet(ctx context.Context, zone string, id types.ID, subnetID types.ID, param *InternetUpdateSubnetRequest) (*InternetSubnetOperationResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet/{{.subnetID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"subnetID":   subnetID,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if subnetID == types.ID(int64(0)) {
		subnetID = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateSubnetRequest{}
	}
	args := &struct {
		Argzone     string
		Argid       types.ID
		ArgsubnetID types.ID
		Argparam    *InternetUpdateSubnetRequest `mapconv:",squash"`
	}{
		Argzone:     zone,
		Argid:       id,
		ArgsubnetID: subnetID,
		Argparam:    param,
	}

	v := &internetUpdateSubnetRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateSubnetResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetUpdateSubnetResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Subnet, nil
}

// DeleteSubnet is API call
func (o *InternetOp) DeleteSubnet(ctx context.Context, zone string, id types.ID, subnetID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet/{{.subnetID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"subnetID":   subnetID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *InternetOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*RouterActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &internetMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &internetMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.RouterActivity, nil
}

/*************************************************
* LoadBalancerOp
*************************************************/

// LoadBalancerOp implements LoadBalancerAPI interface
type LoadBalancerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewLoadBalancerOp creates new LoadBalancerOp instance
func NewLoadBalancerOp(caller APICaller) LoadBalancerAPI {
	return GetClientFactoryFunc("LoadBalancer")(caller).(LoadBalancerAPI)
}

// Find is API call
func (o *LoadBalancerOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*LoadBalancerFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &loadBalancerFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *LoadBalancerOp) Create(ctx context.Context, zone string, param *LoadBalancerCreateRequest) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &LoadBalancerCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *LoadBalancerCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &loadBalancerCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &loadBalancerCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LoadBalancer, nil
}

// Read is API call
func (o *LoadBalancerOp) Read(ctx context.Context, zone string, id types.ID) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &loadBalancerReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LoadBalancer, nil
}

// Update is API call
func (o *LoadBalancerOp) Update(ctx context.Context, zone string, id types.ID, param *LoadBalancerUpdateRequest) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &LoadBalancerUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *LoadBalancerUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &loadBalancerUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &loadBalancerUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LoadBalancer, nil
}

// Delete is API call
func (o *LoadBalancerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *LoadBalancerOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *LoadBalancerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *LoadBalancerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argzone           string
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argzone:           zone,
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &loadBalancerShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *LoadBalancerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorInterface is API call
func (o *LoadBalancerOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &loadBalancerMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &loadBalancerMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

// Status is API call
func (o *LoadBalancerOp) Status(ctx context.Context, zone string, id types.ID) (*LoadBalancerStatusResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/status", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadBalancerStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

/*************************************************
* NFSOp
*************************************************/

// NFSOp implements NFSAPI interface
type NFSOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNFSOp creates new NFSOp instance
func NewNFSOp(caller APICaller) NFSAPI {
	return GetClientFactoryFunc("NFS")(caller).(NFSAPI)
}

// Find is API call
func (o *NFSOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*NFSFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &nFSFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NFSFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *NFSOp) Create(ctx context.Context, zone string, param *NFSCreateRequest) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &NFSCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *NFSCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &nFSCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.NFS, nil
}

// Read is API call
func (o *NFSOp) Read(ctx context.Context, zone string, id types.ID) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.NFS, nil
}

// Update is API call
func (o *NFSOp) Update(ctx context.Context, zone string, id types.ID, param *NFSUpdateRequest) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &NFSUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *NFSUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &nFSUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.NFS, nil
}

// Delete is API call
func (o *NFSOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *NFSOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *NFSOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argzone           string
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argzone:           zone,
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &nFSShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *NFSOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorFreeDiskSize is API call
func (o *NFSOp) MonitorFreeDiskSize(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*FreeDiskSizeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/database/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &nFSMonitorFreeDiskSizeRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSMonitorFreeDiskSizeResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSMonitorFreeDiskSizeResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.FreeDiskSizeActivity, nil
}

// MonitorInterface is API call
func (o *NFSOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &nFSMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nFSMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &nFSMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

/*************************************************
* NoteOp
*************************************************/

// NoteOp implements NoteAPI interface
type NoteOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNoteOp creates new NoteOp instance
func NewNoteOp(caller APICaller) NoteAPI {
	return GetClientFactoryFunc("Note")(caller).(NoteAPI)
}

// Find is API call
func (o *NoteOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*NoteFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &noteFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NoteFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *NoteOp) Create(ctx context.Context, zone string, param *NoteCreateRequest) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &NoteCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *NoteCreateRequest `mapconv:"Note,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &noteCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &noteCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Note, nil
}

// Read is API call
func (o *NoteOp) Read(ctx context.Context, zone string, id types.ID) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &noteReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Note, nil
}

// Update is API call
func (o *NoteOp) Update(ctx context.Context, zone string, id types.ID, param *NoteUpdateRequest) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &NoteUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *NoteUpdateRequest `mapconv:"Note,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &noteUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &noteUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Note, nil
}

// Delete is API call
func (o *NoteOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* PacketFilterOp
*************************************************/

// PacketFilterOp implements PacketFilterAPI interface
type PacketFilterOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewPacketFilterOp creates new PacketFilterOp instance
func NewPacketFilterOp(caller APICaller) PacketFilterAPI {
	return GetClientFactoryFunc("PacketFilter")(caller).(PacketFilterAPI)
}

// Find is API call
func (o *PacketFilterOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*PacketFilterFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &packetFilterFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetFilterFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &PacketFilterFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *PacketFilterOp) Create(ctx context.Context, zone string, param *PacketFilterCreateRequest) (*PacketFilter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &PacketFilterCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *PacketFilterCreateRequest `mapconv:"PacketFilter,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &packetFilterCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetFilterCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &packetFilterCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PacketFilter, nil
}

// Read is API call
func (o *PacketFilterOp) Read(ctx context.Context, zone string, id types.ID) (*PacketFilter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetFilterReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &packetFilterReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PacketFilter, nil
}

// Update is API call
func (o *PacketFilterOp) Update(ctx context.Context, zone string, id types.ID, param *PacketFilterUpdateRequest) (*PacketFilter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &PacketFilterUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *PacketFilterUpdateRequest `mapconv:"PacketFilter,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &packetFilterUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetFilterUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &packetFilterUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.PacketFilter, nil
}

// Delete is API call
func (o *PacketFilterOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* ProxyLBOp
*************************************************/

// ProxyLBOp implements ProxyLBAPI interface
type ProxyLBOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewProxyLBOp creates new ProxyLBOp instance
func NewProxyLBOp(caller APICaller) ProxyLBAPI {
	return GetClientFactoryFunc("ProxyLB")(caller).(ProxyLBAPI)
}

// Find is API call
func (o *ProxyLBOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ProxyLBFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &proxyLBFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ProxyLBFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *ProxyLBOp) Create(ctx context.Context, zone string, param *ProxyLBCreateRequest) (*ProxyLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &ProxyLBCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *ProxyLBCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &proxyLBCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLB, nil
}

// Read is API call
func (o *ProxyLBOp) Read(ctx context.Context, zone string, id types.ID) (*ProxyLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLB, nil
}

// Update is API call
func (o *ProxyLBOp) Update(ctx context.Context, zone string, id types.ID, param *ProxyLBUpdateRequest) (*ProxyLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ProxyLBUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *ProxyLBUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &proxyLBUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLB, nil
}

// Delete is API call
func (o *ProxyLBOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ChangePlan is API call
func (o *ProxyLBOp) ChangePlan(ctx context.Context, zone string, id types.ID, param *ProxyLBChangePlanRequest) (*ProxyLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ProxyLBChangePlanRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *ProxyLBChangePlanRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &proxyLBChangePlanRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBChangePlanResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBChangePlanResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLB, nil
}

// GetCertificates is API call
func (o *ProxyLBOp) GetCertificates(ctx context.Context, zone string, id types.ID) (*ProxyLBCertificates, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/proxylb/sslcertificate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBGetCertificatesResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBGetCertificatesResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLBCertificates, nil
}

// SetCertificates is API call
func (o *ProxyLBOp) SetCertificates(ctx context.Context, zone string, id types.ID, param *ProxyLBSetCertificatesRequest) (*ProxyLBCertificates, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/proxylb/sslcertificate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ProxyLBSetCertificatesRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *ProxyLBSetCertificatesRequest `mapconv:"ProxyLB,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &proxyLBSetCertificatesRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBSetCertificatesResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBSetCertificatesResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLBCertificates, nil
}

// DeleteCertificates is API call
func (o *ProxyLBOp) DeleteCertificates(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/proxylb/sslcertificate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// RenewLetsEncryptCert is API call
func (o *ProxyLBOp) RenewLetsEncryptCert(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/proxylb/letsencryptrenew", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// HealthStatus is API call
func (o *ProxyLBOp) HealthStatus(ctx context.Context, zone string, id types.ID) (*ProxyLBHealth, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/health", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &proxyLBHealthStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &proxyLBHealthStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ProxyLBHealth, nil
}

/*************************************************
* RegionOp
*************************************************/

// RegionOp implements RegionAPI interface
type RegionOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewRegionOp creates new RegionOp instance
func NewRegionOp(caller APICaller) RegionAPI {
	return GetClientFactoryFunc("Region")(caller).(RegionAPI)
}

// Find is API call
func (o *RegionOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*RegionFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &regionFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &regionFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &RegionFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *RegionOp) Read(ctx context.Context, zone string, id types.ID) (*Region, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &regionReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &regionReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Region, nil
}

/*************************************************
* ServerOp
*************************************************/

// ServerOp implements ServerAPI interface
type ServerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewServerOp creates new ServerOp instance
func NewServerOp(caller APICaller) ServerAPI {
	return GetClientFactoryFunc("Server")(caller).(ServerAPI)
}

// Find is API call
func (o *ServerOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ServerFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &serverFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *ServerOp) Create(ctx context.Context, zone string, param *ServerCreateRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &ServerCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *ServerCreateRequest `mapconv:"Server,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &serverCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Server, nil
}

// Read is API call
func (o *ServerOp) Read(ctx context.Context, zone string, id types.ID) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Server, nil
}

// Update is API call
func (o *ServerOp) Update(ctx context.Context, zone string, id types.ID, param *ServerUpdateRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ServerUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *ServerUpdateRequest `mapconv:"Server,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &serverUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Server, nil
}

// Delete is API call
func (o *ServerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ChangePlan is API call
func (o *ServerOp) ChangePlan(ctx context.Context, zone string, id types.ID, plan *ServerChangePlanRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/plan", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"plan":       plan,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if plan == nil {
		plan = &ServerChangePlanRequest{}
	}
	args := &struct {
		Argzone string
		Argid   types.ID
		Argplan *ServerChangePlanRequest `mapconv:",squash"`
	}{
		Argzone: zone,
		Argid:   id,
		Argplan: plan,
	}

	v := &serverChangePlanRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverChangePlanResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverChangePlanResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Server, nil
}

// InsertCDROM is API call
func (o *ServerOp) InsertCDROM(ctx context.Context, zone string, id types.ID, insertParam *InsertCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if insertParam == nil {
		insertParam = &InsertCDROMRequest{}
	}
	args := &struct {
		Argzone        string
		Argid          types.ID
		ArginsertParam *InsertCDROMRequest `mapconv:"CDROM"`
	}{
		Argzone:        zone,
		Argid:          id,
		ArginsertParam: insertParam,
	}

	v := &serverInsertCDROMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// EjectCDROM is API call
func (o *ServerOp) EjectCDROM(ctx context.Context, zone string, id types.ID, insertParam *EjectCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if insertParam == nil {
		insertParam = &EjectCDROMRequest{}
	}
	args := &struct {
		Argzone        string
		Argid          types.ID
		ArginsertParam *EjectCDROMRequest `mapconv:"CDROM"`
	}{
		Argzone:        zone,
		Argid:          id,
		ArginsertParam: insertParam,
	}

	v := &serverEjectCDROMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *ServerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *ServerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argzone           string
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argzone:           zone,
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &serverShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *ServerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *ServerOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*CPUTimeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &serverMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &serverMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.CPUTimeActivity, nil
}

/*************************************************
* SIMOp
*************************************************/

// SIMOp implements SIMAPI interface
type SIMOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSIMOp creates new SIMOp instance
func NewSIMOp(caller APICaller) SIMAPI {
	return GetClientFactoryFunc("SIM")(caller).(SIMAPI)
}

// Find is API call
func (o *SIMOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*SIMFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &sIMFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *SIMOp) Create(ctx context.Context, zone string, param *SIMCreateRequest) (*SIM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &SIMCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *SIMCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &sIMCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIM, nil
}

// Read is API call
func (o *SIMOp) Read(ctx context.Context, zone string, id types.ID) (*SIM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIM, nil
}

// Update is API call
func (o *SIMOp) Update(ctx context.Context, zone string, id types.ID, param *SIMUpdateRequest) (*SIM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SIMUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &sIMUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SIM, nil
}

// Delete is API call
func (o *SIMOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Activate is API call
func (o *SIMOp) Activate(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/activate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Deactivate is API call
func (o *SIMOp) Deactivate(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/deactivate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// AssignIP is API call
func (o *SIMOp) AssignIP(ctx context.Context, zone string, id types.ID, param *SIMAssignIPRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/ip", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMAssignIPRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SIMAssignIPRequest `mapconv:"SIM,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &sIMAssignIPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ClearIP is API call
func (o *SIMOp) ClearIP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/ip", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// IMEILock is API call
func (o *SIMOp) IMEILock(ctx context.Context, zone string, id types.ID, param *SIMIMEILockRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/imeilock", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMIMEILockRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SIMIMEILockRequest `mapconv:"SIM,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &sIMIMEILockRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// IMEIUnlock is API call
func (o *SIMOp) IMEIUnlock(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/imeilock", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Logs is API call
func (o *SIMOp) Logs(ctx context.Context, zone string, id types.ID) (*SIMLogsResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/sessionlog", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMLogsResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMLogsResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// GetNetworkOperator is API call
func (o *SIMOp) GetNetworkOperator(ctx context.Context, zone string, id types.ID) (*SIMGetNetworkOperatorResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/network_operator_config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMGetNetworkOperatorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMGetNetworkOperatorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// SetNetworkOperator is API call
func (o *SIMOp) SetNetworkOperator(ctx context.Context, zone string, id types.ID, configs *SIMNetworkOperatorConfigs) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/network_operator_config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"configs":    configs,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if configs == nil {
		configs = &SIMNetworkOperatorConfigs{}
	}
	args := &struct {
		Argzone    string
		Argid      types.ID
		Argconfigs *SIMNetworkOperatorConfigs `mapconv:",squash"`
	}{
		Argzone:    zone,
		Argid:      id,
		Argconfigs: configs,
	}

	v := &sIMSetNetworkOperatorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorSIM is API call
func (o *SIMOp) MonitorSIM(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*LinkActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/metrics/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &sIMMonitorSIMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sIMMonitorSIMResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sIMMonitorSIMResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.LinkActivity, nil
}

/*************************************************
* SimpleMonitorOp
*************************************************/

// SimpleMonitorOp implements SimpleMonitorAPI interface
type SimpleMonitorOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSimpleMonitorOp creates new SimpleMonitorOp instance
func NewSimpleMonitorOp(caller APICaller) SimpleMonitorAPI {
	return GetClientFactoryFunc("SimpleMonitor")(caller).(SimpleMonitorAPI)
}

// Find is API call
func (o *SimpleMonitorOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*SimpleMonitorFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &simpleMonitorFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SimpleMonitorFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *SimpleMonitorOp) Create(ctx context.Context, zone string, param *SimpleMonitorCreateRequest) (*SimpleMonitor, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &SimpleMonitorCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *SimpleMonitorCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &simpleMonitorCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SimpleMonitor, nil
}

// Read is API call
func (o *SimpleMonitorOp) Read(ctx context.Context, zone string, id types.ID) (*SimpleMonitor, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SimpleMonitor, nil
}

// Update is API call
func (o *SimpleMonitorOp) Update(ctx context.Context, zone string, id types.ID, param *SimpleMonitorUpdateRequest) (*SimpleMonitor, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SimpleMonitorUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SimpleMonitorUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &simpleMonitorUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SimpleMonitor, nil
}

// Delete is API call
func (o *SimpleMonitorOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorResponseTime is API call
func (o *SimpleMonitorOp) MonitorResponseTime(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*ResponseTimeSecActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}//activity/responsetimesec/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &simpleMonitorMonitorResponseTimeRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorMonitorResponseTimeResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorMonitorResponseTimeResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.ResponseTimeSecActivity, nil
}

// HealthStatus is API call
func (o *SimpleMonitorOp) HealthStatus(ctx context.Context, zone string, id types.ID) (*SimpleMonitorHealthStatus, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/health", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simpleMonitorHealthStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &simpleMonitorHealthStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SimpleMonitorHealthStatus, nil
}

/*************************************************
* SSHKeyOp
*************************************************/

// SSHKeyOp implements SSHKeyAPI interface
type SSHKeyOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSSHKeyOp creates new SSHKeyOp instance
func NewSSHKeyOp(caller APICaller) SSHKeyAPI {
	return GetClientFactoryFunc("SSHKey")(caller).(SSHKeyAPI)
}

// Find is API call
func (o *SSHKeyOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*SSHKeyFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &sSHKeyFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SSHKeyFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *SSHKeyOp) Create(ctx context.Context, zone string, param *SSHKeyCreateRequest) (*SSHKey, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &SSHKeyCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *SSHKeyCreateRequest `mapconv:"SSHKey,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &sSHKeyCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sSHKeyCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SSHKey, nil
}

// Generate is API call
func (o *SSHKeyOp) Generate(ctx context.Context, zone string, param *SSHKeyGenerateRequest) (*SSHKeyGenerated, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/generate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &SSHKeyGenerateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *SSHKeyGenerateRequest `mapconv:"SSHKey,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &sSHKeyGenerateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyGenerateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sSHKeyGenerateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SSHKeyGenerated, nil
}

// Read is API call
func (o *SSHKeyOp) Read(ctx context.Context, zone string, id types.ID) (*SSHKey, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sSHKeyReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SSHKey, nil
}

// Update is API call
func (o *SSHKeyOp) Update(ctx context.Context, zone string, id types.ID, param *SSHKeyUpdateRequest) (*SSHKey, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SSHKeyUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SSHKeyUpdateRequest `mapconv:"SSHKey,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &sSHKeyUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &sSHKeyUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &sSHKeyUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.SSHKey, nil
}

// Delete is API call
func (o *SSHKeyOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* SwitchOp
*************************************************/

// SwitchOp implements SwitchAPI interface
type SwitchOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSwitchOp creates new SwitchOp instance
func NewSwitchOp(caller APICaller) SwitchAPI {
	return GetClientFactoryFunc("Switch")(caller).(SwitchAPI)
}

// Find is API call
func (o *SwitchOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*SwitchFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &switchFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SwitchFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *SwitchOp) Create(ctx context.Context, zone string, param *SwitchCreateRequest) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &SwitchCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *SwitchCreateRequest `mapconv:"Switch,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &switchCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &switchCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Switch, nil
}

// Read is API call
func (o *SwitchOp) Read(ctx context.Context, zone string, id types.ID) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &switchReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Switch, nil
}

// Update is API call
func (o *SwitchOp) Update(ctx context.Context, zone string, id types.ID, param *SwitchUpdateRequest) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SwitchUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SwitchUpdateRequest `mapconv:"Switch,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &switchUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &switchUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Switch, nil
}

// Delete is API call
func (o *SwitchOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToBridge is API call
func (o *SwitchOp) ConnectToBridge(ctx context.Context, zone string, id types.ID, bridgeID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge/{{.bridgeID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"bridgeID":   bridgeID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromBridge is API call
func (o *SwitchOp) DisconnectFromBridge(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge/", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* VPCRouterOp
*************************************************/

// VPCRouterOp implements VPCRouterAPI interface
type VPCRouterOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewVPCRouterOp creates new VPCRouterOp instance
func NewVPCRouterOp(caller APICaller) VPCRouterAPI {
	return GetClientFactoryFunc("VPCRouter")(caller).(VPCRouterAPI)
}

// Find is API call
func (o *VPCRouterOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*VPCRouterFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &vPCRouterFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &VPCRouterFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Create is API call
func (o *VPCRouterOp) Create(ctx context.Context, zone string, param *VPCRouterCreateRequest) (*VPCRouter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &VPCRouterCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *VPCRouterCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &vPCRouterCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &vPCRouterCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.VPCRouter, nil
}

// Read is API call
func (o *VPCRouterOp) Read(ctx context.Context, zone string, id types.ID) (*VPCRouter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &vPCRouterReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.VPCRouter, nil
}

// Update is API call
func (o *VPCRouterOp) Update(ctx context.Context, zone string, id types.ID, param *VPCRouterUpdateRequest) (*VPCRouter, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &VPCRouterUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *VPCRouterUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &vPCRouterUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &vPCRouterUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.VPCRouter, nil
}

// Delete is API call
func (o *VPCRouterOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *VPCRouterOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *VPCRouterOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *VPCRouterOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argzone           string
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argzone:           zone,
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &vPCRouterShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *VPCRouterOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *VPCRouterOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, nicIndex int, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{.nicIndex}}/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"nicIndex":   nicIndex,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *VPCRouterOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID, nicIndex int) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{.nicIndex}}/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"nicIndex":   nicIndex,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorInterface is API call
func (o *VPCRouterOp) MonitorInterface(ctx context.Context, zone string, id types.ID, index int, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{if eq .index 0}}{{.index}}{{end}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"index":      index,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if index == 0 {
		index = 0
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argindex     int
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argindex:     index,
		Argcondition: condition,
	}

	v := &vPCRouterMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vPCRouterMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &vPCRouterMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.InterfaceActivity, nil
}

/*************************************************
* ZoneOp
*************************************************/

// ZoneOp implements ZoneAPI interface
type ZoneOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewZoneOp creates new ZoneOp instance
func NewZoneOp(caller APICaller) ZoneAPI {
	return GetClientFactoryFunc("Zone")(caller).(ZoneAPI)
}

// Find is API call
func (o *ZoneOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ZoneFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &zoneFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &zoneFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ZoneFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, err
}

// Read is API call
func (o *ZoneOp) Read(ctx context.Context, zone string, id types.ID) (*Zone, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &zoneReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &zoneReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results.Zone, nil
}
